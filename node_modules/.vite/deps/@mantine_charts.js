import {
  Area,
  AreaChart,
  Bar,
  BarChart,
  CartesianGrid,
  Cell,
  ComposedChart,
  Funnel,
  FunnelChart,
  Label,
  LabelList,
  Legend,
  Line,
  LineChart,
  Pie,
  PieChart,
  PolarAngleAxis,
  PolarGrid,
  PolarRadiusAxis,
  Radar,
  RadarChart,
  RadialBar,
  RadialBarChart,
  ReferenceLine,
  ResponsiveContainer,
  Scatter,
  ScatterChart,
  Tooltip,
  XAxis,
  YAxis,
  ZAxis
} from "./chunk-RCQFQEK5.js";
import "./chunk-DH77IWQY.js";
import "./chunk-4EZWJUAX.js";
import "./chunk-CMASI5CY.js";
import {
  Box,
  ColorSwatch,
  Group,
  Paper,
  Text,
  createVarsResolver,
  factory,
  getThemeColor,
  rem,
  useMantineTheme,
  useProps,
  useResolvedStylesApi,
  useStyles
} from "./chunk-T5QIBJED.js";
import "./chunk-ZEPD5I6A.js";
import "./chunk-3PSBCGNU.js";
import "./chunk-H5YQAEFC.js";
import {
  require_jsx_runtime
} from "./chunk-CBL72VMY.js";
import {
  useId
} from "./chunk-22UVDF7D.js";
import {
  require_react
} from "./chunk-B3GNVBX2.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/ChartTooltip/ChartTooltip.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/utils/get-series-labels/get-series-labels.mjs
function getSeriesLabels(series) {
  if (!series) {
    return {};
  }
  return series.reduce((acc, item) => {
    const matchFound = item.name.search(/\./);
    if (matchFound >= 0) {
      const key = item.name.substring(matchFound + 1);
      acc[key] = item.label;
      return acc;
    }
    acc[item.name] = item.label;
    return acc;
  }, {});
}

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/ChartTooltip/ChartTooltip.module.css.mjs
var classes = { "tooltip": "m_e4d36c9b", "tooltipLabel": "m_7f4bcb19", "tooltipBody": "m_3de554dd", "tooltipItemColor": "m_b30369b5", "tooltipItem": "m_3de8964e", "tooltipItemBody": "m_50186d10", "tooltipItemName": "m_501dadf9", "tooltipItemData": "m_50192318" };

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/ChartTooltip/ChartTooltip.mjs
function updateChartTooltipPayload(payload) {
  return payload.map((item) => {
    if (!item.payload || item.payload[item.name]) {
      return item;
    }
    const matchFound = item.name.search(/\./);
    if (matchFound >= 0) {
      const newDataKey = item.name.substring(0, matchFound);
      const nestedPayload = { ...item.payload[newDataKey] };
      const shallowPayload = Object.entries(item.payload).reduce((acc, current) => {
        const [k, v] = current;
        return k === newDataKey ? acc : { ...acc, [k]: v };
      }, {});
      return {
        ...item,
        name: item.name.substring(matchFound + 1),
        payload: {
          ...shallowPayload,
          ...nestedPayload
        }
      };
    }
    return item;
  });
}
function getFilteredChartTooltipPayload(payload, segmentId) {
  const duplicatesFilter = updateChartTooltipPayload(
    payload.filter((item) => item.fill !== "none" || !item.color)
  );
  if (!segmentId) {
    return duplicatesFilter;
  }
  return duplicatesFilter.filter((item) => item.name === segmentId);
}
function getData(item, type) {
  if (type === "radial" || type === "scatter") {
    if (Array.isArray(item.value)) {
      return item.value[1] - item.value[0];
    }
    return item.value;
  }
  if (Array.isArray(item.payload[item.dataKey])) {
    return item.payload[item.dataKey][1] - item.payload[item.dataKey][0];
  }
  return item.payload[item.name];
}
var defaultProps = {
  type: "area",
  showColor: true
};
var ChartTooltip = factory((_props, ref) => {
  var _a, _b;
  const props = useProps("ChartTooltip", defaultProps, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    payload,
    label,
    unit,
    type,
    segmentId,
    mod,
    series,
    valueFormatter,
    showColor,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "ChartTooltip",
    classes,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled
  });
  if (!payload) {
    return null;
  }
  const filteredPayload = getFilteredChartTooltipPayload(payload, segmentId);
  const scatterLabel = type === "scatter" ? (_b = (_a = payload[0]) == null ? void 0 : _a.payload) == null ? void 0 : _b.name : null;
  const labels = getSeriesLabels(series);
  const _label = label || scatterLabel;
  const items = filteredPayload.map((item) => (0, import_jsx_runtime.jsxs)("div", { "data-type": type, ...getStyles("tooltipItem"), children: [
    (0, import_jsx_runtime.jsxs)("div", { ...getStyles("tooltipItemBody"), children: [
      showColor && (0, import_jsx_runtime.jsx)("svg", { ...getStyles("tooltipItemColor"), children: (0, import_jsx_runtime.jsx)(
        "circle",
        {
          r: 6,
          fill: getThemeColor(item.color, theme),
          width: 12,
          height: 12,
          cx: 6,
          cy: 6
        }
      ) }),
      (0, import_jsx_runtime.jsx)("div", { ...getStyles("tooltipItemName"), children: labels[item.name] || item.name })
    ] }),
    (0, import_jsx_runtime.jsxs)("div", { ...getStyles("tooltipItemData"), children: [
      typeof valueFormatter === "function" ? valueFormatter(getData(item, type)) : getData(item, type),
      unit || item.unit
    ] })
  ] }, (item == null ? void 0 : item.key) ?? item.name));
  return (0, import_jsx_runtime.jsxs)(Box, { ...getStyles("tooltip"), mod: [{ type }, mod], ref, ...others, children: [
    _label && (0, import_jsx_runtime.jsx)("div", { ...getStyles("tooltipLabel"), children: _label }),
    (0, import_jsx_runtime.jsx)("div", { ...getStyles("tooltipBody"), children: items })
  ] });
});
ChartTooltip.displayName = "@mantine/charts/ChartTooltip";

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/ChartLegend/ChartLegend.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/ChartLegend/ChartLegend.module.css.mjs
var classes2 = { "legend": "m_847eaf", "legendItem": "m_17da7e62", "legendItemColor": "m_6e236e21", "legendItemName": "m_8ff56c0d" };

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/ChartLegend/ChartLegend.mjs
function updateChartLegendPayload(payload) {
  return payload.map((item) => {
    var _a;
    const newDataKey = (_a = item.dataKey) == null ? void 0 : _a.split(".").pop();
    return {
      ...item,
      dataKey: newDataKey,
      payload: {
        ...item.payload,
        name: newDataKey,
        dataKey: newDataKey
      }
    };
  });
}
function getFilteredChartLegendPayload(payload) {
  return updateChartLegendPayload(payload.filter((item) => item.color !== "none"));
}
var defaultProps2 = {};
var ChartLegend = factory((_props, ref) => {
  const props = useProps("ChartLegend", defaultProps2, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    payload,
    onHighlight,
    legendPosition,
    mod,
    series,
    showColor,
    centered,
    ...others
  } = props;
  const getStyles = useStyles({
    name: "ChartLegend",
    classes: classes2,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled
  });
  if (!payload) {
    return null;
  }
  const filteredPayload = getFilteredChartLegendPayload(payload);
  const labels = getSeriesLabels(series);
  const items = filteredPayload.map((item, index) => (0, import_jsx_runtime2.jsxs)(
    "div",
    {
      ...getStyles("legendItem"),
      onMouseEnter: () => onHighlight(item.dataKey),
      onMouseLeave: () => onHighlight(null),
      "data-without-color": showColor === false || void 0,
      children: [
        (0, import_jsx_runtime2.jsx)(
          ColorSwatch,
          {
            color: item.color,
            size: 12,
            ...getStyles("legendItemColor"),
            withShadow: false
          }
        ),
        (0, import_jsx_runtime2.jsx)("p", { ...getStyles("legendItemName"), children: labels[item.dataKey] || item.dataKey })
      ]
    },
    index
  ));
  return (0, import_jsx_runtime2.jsx)(
    Box,
    {
      ref,
      mod: [{ position: legendPosition, centered }, mod],
      ...getStyles("legend"),
      ...others,
      children: items
    }
  );
});
ChartLegend.displayName = "@mantine/charts/ChartLegend";

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/AreaChart/AreaChart.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/PointLabel/PointLabel.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function PointLabel({ x, y, value, valueFormatter }) {
  return (0, import_jsx_runtime3.jsx)("g", { transform: `translate(${x},${y})`, children: (0, import_jsx_runtime3.jsx)(
    "text",
    {
      x: 0,
      y: 0,
      dy: -8,
      dx: -10,
      textAnchor: "top",
      fill: "var(--chart-text-color, var(--mantine-color-dimmed))",
      fontSize: 8,
      children: valueFormatter ? valueFormatter(value) : value
    }
  ) });
}

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/AreaChart/AreaGradient.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function AreaGradient({ color, id, withGradient, fillOpacity }) {
  return (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: withGradient ? (0, import_jsx_runtime4.jsxs)("linearGradient", { id, x1: "0", y1: "0", x2: "0", y2: "1", children: [
    (0, import_jsx_runtime4.jsx)("stop", { offset: "0%", stopColor: color, stopOpacity: fillOpacity }),
    (0, import_jsx_runtime4.jsx)("stop", { offset: "100%", stopColor: color, stopOpacity: 0.01 })
  ] }) : (0, import_jsx_runtime4.jsx)("linearGradient", { id, x1: "0", y1: "0", x2: "0", y2: "1", children: (0, import_jsx_runtime4.jsx)("stop", { stopColor: color, stopOpacity: fillOpacity ?? 0.2 }) }) });
}
AreaGradient.displayName = "@mantine/charts/AreaGradient";

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/AreaChart/AreaSplit.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
function AreaSplit({ offset, id, colors, fillOpacity }) {
  const theme = useMantineTheme();
  return (0, import_jsx_runtime5.jsxs)("linearGradient", { id, x1: "0", y1: "0", x2: "0", y2: "1", children: [
    (0, import_jsx_runtime5.jsx)(
      "stop",
      {
        offset,
        stopColor: getThemeColor(colors[0], theme),
        stopOpacity: fillOpacity ?? 0.2
      }
    ),
    (0, import_jsx_runtime5.jsx)(
      "stop",
      {
        offset,
        stopColor: getThemeColor(colors[1], theme),
        stopOpacity: fillOpacity ?? 0.2
      }
    )
  ] });
}
AreaSplit.displayName = "@mantine/charts/AreaSplit";

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/AreaChart/get-split-offset.mjs
function getSplitOffset({ data, dataKey }) {
  const dataMax = Math.max(...data.map((item) => item[dataKey]));
  const dataMin = Math.min(...data.map((item) => item[dataKey]));
  if (dataMax <= 0) {
    return 0;
  }
  if (dataMin >= 0) {
    return 1;
  }
  return dataMax / (dataMax - dataMin);
}
function getDefaultSplitOffset({ data, series }) {
  if (series.length === 1) {
    const dataKey = series[0].name;
    return getSplitOffset({ data, dataKey });
  }
  return 0.5;
}

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/grid-chart.module.css.mjs
var classes3 = { "root": "m_a50f3e58", "container": "m_af9188cb", "grid": "m_a50a48bc", "axis": "m_a507a517", "axisLabel": "m_2293801d", "tooltip": "m_92b296cd" };

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/AreaChart/AreaChart.mjs
function valueToPercent(value) {
  return `${(value * 100).toFixed(0)}%`;
}
var defaultProps3 = {
  withXAxis: true,
  withYAxis: true,
  withDots: true,
  withTooltip: true,
  connectNulls: true,
  strokeWidth: 2,
  tooltipAnimationDuration: 0,
  fillOpacity: 0.2,
  tickLine: "y",
  strokeDasharray: "5 5",
  curveType: "monotone",
  gridAxis: "x",
  type: "default",
  splitColors: ["green.7", "red.7"],
  orientation: "horizontal"
};
var varsResolver = createVarsResolver((theme, { textColor, gridColor }) => ({
  root: {
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0
  }
}));
var AreaChart2 = factory((_props, ref) => {
  const props = useProps("AreaChart", defaultProps3, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    series,
    withGradient,
    dataKey,
    withXAxis,
    withYAxis,
    curveType,
    gridProps,
    withDots,
    tickLine,
    strokeDasharray,
    gridAxis,
    unit,
    yAxisProps,
    xAxisProps,
    dotProps,
    activeDotProps,
    strokeWidth,
    tooltipAnimationDuration,
    type,
    legendProps,
    tooltipProps,
    withLegend,
    withTooltip,
    areaChartProps,
    fillOpacity,
    splitColors,
    splitOffset,
    connectNulls,
    onMouseLeave,
    orientation,
    referenceLines,
    dir,
    valueFormatter,
    children,
    areaProps,
    xAxisLabel,
    yAxisLabel,
    withRightYAxis,
    rightYAxisLabel,
    rightYAxisProps,
    withPointLabels,
    ...others
  } = props;
  const theme = useMantineTheme();
  const baseId = (0, import_react.useId)();
  const splitId = `${baseId}-split`;
  const withXTickLine = gridAxis !== "none" && (tickLine === "x" || tickLine === "xy");
  const withYTickLine = gridAxis !== "none" && (tickLine === "y" || tickLine === "xy");
  const isAnimationActive = (tooltipAnimationDuration || 0) > 0;
  const _withGradient = typeof withGradient === "boolean" ? withGradient : type === "default";
  const stacked = type === "stacked" || type === "percent";
  const [highlightedArea, setHighlightedArea] = (0, import_react.useState)(null);
  const shouldHighlight = highlightedArea !== null;
  const handleMouseLeave = (event) => {
    setHighlightedArea(null);
    onMouseLeave == null ? void 0 : onMouseLeave(event);
  };
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const getStyles = useStyles({
    name: "AreaChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver
  });
  const dotsAreas = series.map((item) => {
    const color = getThemeColor(item.color, theme);
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return (0, import_react.createElement)(
      Area,
      {
        ...getStyles("area"),
        activeDot: { fill: theme.white, stroke: color, strokeWidth: 2, r: 4, ...activeDotProps },
        dot: { fill: color, fillOpacity: dimmed ? 0 : 1, strokeWidth: 2, r: 4, ...dotProps },
        key: item.name,
        name: item.name,
        type: curveType,
        dataKey: item.name,
        fill: "none",
        strokeWidth,
        stroke: "none",
        isAnimationActive: false,
        connectNulls,
        stackId: stacked ? "stack-dots" : void 0,
        yAxisId: item.yAxisId || "left",
        ...typeof areaProps === "function" ? areaProps(item) : areaProps
      }
    );
  });
  const areas = series.map((item) => {
    const id = `${baseId}-${item.color.replace(/[^a-zA-Z0-9]/g, "")}`;
    const color = getThemeColor(item.color, theme);
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return (0, import_jsx_runtime6.jsxs)(import_react.Fragment, { children: [
      (0, import_jsx_runtime6.jsx)("defs", { children: (0, import_jsx_runtime6.jsx)(
        AreaGradient,
        {
          color,
          withGradient: _withGradient,
          id,
          fillOpacity
        }
      ) }),
      (0, import_jsx_runtime6.jsx)(
        Area,
        {
          ...getStyles("area"),
          activeDot: false,
          dot: false,
          name: item.name,
          type: curveType,
          dataKey: item.name,
          fill: type === "split" ? `url(#${splitId})` : `url(#${id})`,
          strokeWidth,
          stroke: color,
          isAnimationActive: false,
          connectNulls,
          stackId: stacked ? "stack" : void 0,
          fillOpacity: dimmed ? 0 : 1,
          strokeOpacity: dimmed ? 0.5 : 1,
          strokeDasharray: item.strokeDasharray,
          yAxisId: item.yAxisId || "left",
          label: withPointLabels ? (0, import_jsx_runtime6.jsx)(PointLabel, { valueFormatter }) : void 0,
          ...typeof areaProps === "function" ? areaProps(item) : areaProps
        }
      )
    ] }, item.name);
  });
  const referenceLinesItems = referenceLines == null ? void 0 : referenceLines.map((line, index) => {
    const color = getThemeColor(line.color, theme);
    return (0, import_jsx_runtime6.jsx)(
      ReferenceLine,
      {
        stroke: line.color ? color : "var(--chart-grid-color)",
        strokeWidth: 1,
        yAxisId: line.yAxisId || "left",
        ...line,
        label: {
          value: line.label,
          fill: line.color ? color : "currentColor",
          fontSize: 12,
          position: line.labelPosition ?? "insideBottomLeft"
        },
        ...getStyles("referenceLine")
      },
      index
    );
  });
  const tickFormatter = type === "percent" ? valueToPercent : valueFormatter;
  const sharedYAxisProps = {
    axisLine: false,
    ...orientation === "vertical" ? { dataKey, type: "category" } : { type: "number" },
    tickLine: withYTickLine ? { stroke: "currentColor" } : false,
    allowDecimals: true,
    unit,
    tickFormatter: orientation === "vertical" ? void 0 : tickFormatter,
    ...getStyles("axis")
  };
  return (0, import_jsx_runtime6.jsx)(
    Box,
    {
      ref,
      ...getStyles("root"),
      onMouseLeave: handleMouseLeave,
      dir: dir || "ltr",
      ...others,
      children: (0, import_jsx_runtime6.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime6.jsxs)(
        AreaChart,
        {
          data,
          stackOffset: type === "percent" ? "expand" : void 0,
          layout: orientation,
          margin: {
            bottom: xAxisLabel ? 30 : void 0,
            left: yAxisLabel ? 10 : void 0,
            right: yAxisLabel ? 5 : void 0
          },
          ...areaChartProps,
          children: [
            referenceLinesItems,
            withLegend && (0, import_jsx_runtime6.jsx)(
              Legend,
              {
                verticalAlign: "top",
                content: (payload) => (0, import_jsx_runtime6.jsx)(
                  ChartLegend,
                  {
                    payload: payload.payload,
                    onHighlight: setHighlightedArea,
                    legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "top",
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series
                  }
                ),
                ...legendProps
              }
            ),
            (0, import_jsx_runtime6.jsx)(
              CartesianGrid,
              {
                strokeDasharray,
                vertical: gridAxis === "y" || gridAxis === "xy",
                horizontal: gridAxis === "x" || gridAxis === "xy",
                ...getStyles("grid"),
                ...gridProps
              }
            ),
            (0, import_jsx_runtime6.jsxs)(
              XAxis,
              {
                hide: !withXAxis,
                ...orientation === "vertical" ? { type: "number" } : { dataKey },
                tick: { transform: "translate(0, 10)", fontSize: 12, fill: "currentColor" },
                stroke: "",
                interval: "preserveStartEnd",
                tickLine: withXTickLine ? { stroke: "currentColor" } : false,
                minTickGap: 5,
                tickFormatter: orientation === "vertical" ? tickFormatter : void 0,
                ...getStyles("axis"),
                ...xAxisProps,
                children: [
                  xAxisLabel && (0, import_jsx_runtime6.jsx)(Label, { position: "insideBottom", offset: -20, fontSize: 12, ...getStyles("axisLabel"), children: xAxisLabel }),
                  xAxisProps == null ? void 0 : xAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime6.jsxs)(
              YAxis,
              {
                yAxisId: "left",
                orientation: "left",
                tick: { transform: "translate(-10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withYAxis,
                ...sharedYAxisProps,
                ...yAxisProps,
                children: [
                  yAxisLabel && (0, import_jsx_runtime6.jsx)(
                    Label,
                    {
                      position: "insideLeft",
                      angle: -90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: yAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime6.jsxs)(
              YAxis,
              {
                yAxisId: "right",
                orientation: "right",
                tick: { transform: "translate(10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withRightYAxis,
                ...sharedYAxisProps,
                ...rightYAxisProps,
                children: [
                  rightYAxisLabel && (0, import_jsx_runtime6.jsx)(
                    Label,
                    {
                      position: "insideRight",
                      angle: 90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: rightYAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            withTooltip && (0, import_jsx_runtime6.jsx)(
              Tooltip,
              {
                animationDuration: tooltipAnimationDuration,
                isAnimationActive,
                position: orientation === "vertical" ? {} : { y: 0 },
                cursor: {
                  stroke: "var(--chart-grid-color)",
                  strokeWidth: 1,
                  strokeDasharray
                },
                content: ({ label, payload }) => (0, import_jsx_runtime6.jsx)(
                  ChartTooltip,
                  {
                    label,
                    payload,
                    unit,
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    valueFormatter
                  }
                ),
                ...tooltipProps
              }
            ),
            type === "split" && (0, import_jsx_runtime6.jsx)("defs", { children: (0, import_jsx_runtime6.jsx)(
              AreaSplit,
              {
                colors: splitColors,
                id: splitId,
                offset: splitOffset ?? getDefaultSplitOffset({ data, series }),
                fillOpacity
              }
            ) }),
            areas,
            withDots && dotsAreas,
            children
          ]
        }
      ) })
    }
  );
});
AreaChart2.classes = classes3;
AreaChart2.displayName = "@mantine/charts/AreaChart";

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/BarChart/BarChart.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
function valueToPercent2(value) {
  return `${(value * 100).toFixed(0)}%`;
}
var defaultProps4 = {
  withXAxis: true,
  withYAxis: true,
  withTooltip: true,
  tooltipAnimationDuration: 0,
  fillOpacity: 1,
  tickLine: "y",
  strokeDasharray: "5 5",
  gridAxis: "x",
  type: "default"
};
var varsResolver2 = createVarsResolver(
  (theme, { textColor, gridColor, cursorFill, barLabelColor }) => ({
    root: {
      "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
      "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0,
      "--chart-cursor-fill": cursorFill ? getThemeColor(cursorFill, theme) : void 0,
      "--chart-bar-label-color": barLabelColor ? getThemeColor(barLabelColor, theme) : void 0
    }
  })
);
function calculateCumulativeTotal(waterfallData, dataKey) {
  let start = 0;
  let end = 0;
  return waterfallData.map((item) => {
    if (item.standalone) {
      for (const prop in item) {
        if (typeof item[prop] === "number" && prop !== dataKey) {
          item[prop] = [0, item[prop]];
        }
      }
    } else {
      for (const prop in item) {
        if (typeof item[prop] === "number" && prop !== dataKey) {
          end += item[prop];
          item[prop] = [start, end];
          start = end;
        }
      }
    }
    return item;
  });
}
function getBarFill(barProps, series) {
  if (typeof barProps === "function") {
    return barProps(series).fill;
  }
  return barProps == null ? void 0 : barProps.fill;
}
var BarChart2 = factory((_props, ref) => {
  const props = useProps("BarChart", defaultProps4, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withLegend,
    legendProps,
    series,
    onMouseLeave,
    dataKey,
    withTooltip,
    withXAxis,
    withYAxis,
    gridAxis,
    tickLine,
    xAxisProps,
    yAxisProps,
    unit,
    tooltipAnimationDuration,
    strokeDasharray,
    gridProps,
    tooltipProps,
    referenceLines,
    fillOpacity,
    barChartProps,
    type,
    orientation,
    dir,
    valueFormatter,
    children,
    barProps,
    xAxisLabel,
    yAxisLabel,
    withBarValueLabel,
    valueLabelProps,
    withRightYAxis,
    rightYAxisLabel,
    rightYAxisProps,
    minBarSize,
    maxBarWidth,
    mod,
    getBarColor,
    gridColor,
    ...others
  } = props;
  const theme = useMantineTheme();
  const withXTickLine = gridAxis !== "none" && (tickLine === "x" || tickLine === "xy");
  const withYTickLine = gridAxis !== "none" && (tickLine === "y" || tickLine === "xy");
  const [highlightedArea, setHighlightedArea] = (0, import_react2.useState)(null);
  const shouldHighlight = highlightedArea !== null;
  const stacked = type === "stacked" || type === "percent";
  const tickFormatter = type === "percent" ? valueToPercent2 : valueFormatter;
  const handleMouseLeave = (event) => {
    setHighlightedArea(null);
    onMouseLeave == null ? void 0 : onMouseLeave(event);
  };
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const inputData = type === "waterfall" ? calculateCumulativeTotal(data, dataKey) : data;
  const getStyles = useStyles({
    name: "BarChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver2
  });
  const bars = series.map((item) => {
    const color = getThemeColor(item.color, theme);
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return (0, import_react2.createElement)(
      Bar,
      {
        ...getStyles("bar"),
        key: item.name,
        name: item.name,
        dataKey: item.name,
        fill: color,
        stroke: color,
        isAnimationActive: false,
        fillOpacity: dimmed ? 0.1 : fillOpacity,
        strokeOpacity: dimmed ? 0.2 : 0,
        stackId: stacked ? "stack" : item.stackId || void 0,
        yAxisId: item.yAxisId || "left",
        minPointSize: minBarSize,
        ...typeof barProps === "function" ? barProps(item) : barProps
      },
      inputData.map((entry, index) => {
        const cellColor = entry.color ? getThemeColor(entry.color, theme) : typeof getBarColor === "function" ? getThemeColor(getBarColor(entry[item.name], item), theme) : getBarFill(barProps, item) || color;
        return (0, import_jsx_runtime7.jsx)(Cell, { fill: cellColor }, `cell-${index}`);
      }),
      withBarValueLabel && (0, import_jsx_runtime7.jsx)(
        LabelList,
        {
          position: orientation === "vertical" ? "right" : "top",
          fontSize: 12,
          fill: "var(--chart-bar-label-color, var(--mantine-color-dimmed))",
          formatter: tickFormatter,
          ...typeof valueLabelProps === "function" ? valueLabelProps(item) : valueLabelProps
        }
      )
    );
  });
  const referenceLinesItems = referenceLines == null ? void 0 : referenceLines.map((line, index) => {
    const color = getThemeColor(line.color, theme);
    return (0, import_jsx_runtime7.jsx)(
      ReferenceLine,
      {
        stroke: line.color ? color : "var(--chart-grid-color)",
        strokeWidth: 1,
        yAxisId: line.yAxisId || "left",
        ...line,
        label: {
          value: line.label,
          fill: line.color ? color : "currentColor",
          fontSize: 12,
          position: line.labelPosition ?? "insideBottomLeft"
        },
        ...getStyles("referenceLine")
      },
      index
    );
  });
  const sharedYAxisProps = {
    axisLine: false,
    ...orientation === "vertical" ? { dataKey, type: "category" } : { type: "number" },
    tickLine: withYTickLine ? { stroke: "currentColor" } : false,
    allowDecimals: true,
    unit,
    tickFormatter: orientation === "vertical" ? void 0 : tickFormatter,
    ...getStyles("axis")
  };
  return (0, import_jsx_runtime7.jsx)(
    Box,
    {
      ref,
      ...getStyles("root"),
      onMouseLeave: handleMouseLeave,
      dir: dir || "ltr",
      mod: [{ orientation }, mod],
      ...others,
      children: (0, import_jsx_runtime7.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime7.jsxs)(
        BarChart,
        {
          data: inputData,
          stackOffset: type === "percent" ? "expand" : void 0,
          layout: orientation,
          maxBarSize: maxBarWidth,
          margin: {
            bottom: xAxisLabel ? 30 : void 0,
            left: yAxisLabel ? 10 : void 0,
            right: yAxisLabel ? 5 : void 0
          },
          ...barChartProps,
          children: [
            withLegend && (0, import_jsx_runtime7.jsx)(
              Legend,
              {
                verticalAlign: "top",
                content: (payload) => (0, import_jsx_runtime7.jsx)(
                  ChartLegend,
                  {
                    payload: payload.payload,
                    onHighlight: setHighlightedArea,
                    legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "top",
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    showColor: type !== "waterfall"
                  }
                ),
                ...legendProps
              }
            ),
            (0, import_jsx_runtime7.jsxs)(
              XAxis,
              {
                hide: !withXAxis,
                ...orientation === "vertical" ? { type: "number" } : { dataKey },
                tick: { transform: "translate(0, 10)", fontSize: 12, fill: "currentColor" },
                stroke: "",
                interval: "preserveStartEnd",
                tickLine: withXTickLine ? { stroke: "currentColor" } : false,
                minTickGap: 5,
                tickFormatter: orientation === "vertical" ? tickFormatter : void 0,
                ...getStyles("axis"),
                ...xAxisProps,
                children: [
                  xAxisLabel && (0, import_jsx_runtime7.jsx)(Label, { position: "insideBottom", offset: -20, fontSize: 12, ...getStyles("axisLabel"), children: xAxisLabel }),
                  xAxisProps == null ? void 0 : xAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime7.jsxs)(
              YAxis,
              {
                yAxisId: "left",
                orientation: "left",
                tick: { transform: "translate(-10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withYAxis,
                ...sharedYAxisProps,
                ...yAxisProps,
                children: [
                  yAxisLabel && (0, import_jsx_runtime7.jsx)(
                    Label,
                    {
                      position: "insideLeft",
                      angle: -90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: yAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime7.jsxs)(
              YAxis,
              {
                yAxisId: "right",
                orientation: "right",
                tick: { transform: "translate(10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withRightYAxis,
                ...sharedYAxisProps,
                ...rightYAxisProps,
                children: [
                  rightYAxisLabel && (0, import_jsx_runtime7.jsx)(
                    Label,
                    {
                      position: "insideRight",
                      angle: 90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: rightYAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime7.jsx)(
              CartesianGrid,
              {
                strokeDasharray,
                vertical: gridAxis === "y" || gridAxis === "xy",
                horizontal: gridAxis === "x" || gridAxis === "xy",
                ...getStyles("grid"),
                ...gridProps
              }
            ),
            withTooltip && (0, import_jsx_runtime7.jsx)(
              Tooltip,
              {
                animationDuration: tooltipAnimationDuration,
                isAnimationActive: tooltipAnimationDuration !== 0,
                position: orientation === "vertical" ? {} : { y: 0 },
                cursor: {
                  stroke: "var(--chart-grid-color)",
                  strokeWidth: 1,
                  strokeDasharray,
                  fill: "var(--chart-cursor-fill)"
                },
                content: ({ label, payload }) => (0, import_jsx_runtime7.jsx)(
                  ChartTooltip,
                  {
                    label,
                    payload,
                    type: type === "waterfall" ? "scatter" : void 0,
                    unit,
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    valueFormatter
                  }
                ),
                ...tooltipProps
              }
            ),
            bars,
            referenceLinesItems,
            children
          ]
        }
      ) })
    }
  );
});
BarChart2.displayName = "@mantine/charts/BarChart";
BarChart2.classes = classes3;

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/LineChart/LineChart.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var defaultProps5 = {
  withXAxis: true,
  withYAxis: true,
  withTooltip: true,
  tooltipAnimationDuration: 0,
  fillOpacity: 1,
  tickLine: "y",
  strokeDasharray: "5 5",
  gridAxis: "x",
  withDots: true,
  connectNulls: true,
  strokeWidth: 2,
  curveType: "monotone",
  gradientStops: [
    { offset: 0, color: "red" },
    { offset: 100, color: "blue" }
  ]
};
var varsResolver3 = createVarsResolver((theme, { textColor, gridColor }) => ({
  root: {
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0
  }
}));
var LineChart2 = factory((_props, ref) => {
  const props = useProps("LineChart", defaultProps5, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withLegend,
    legendProps,
    series,
    onMouseLeave,
    dataKey,
    withTooltip,
    withXAxis,
    withYAxis,
    gridAxis,
    tickLine,
    xAxisProps,
    yAxisProps,
    unit,
    tooltipAnimationDuration,
    strokeDasharray,
    gridProps,
    tooltipProps,
    referenceLines,
    withDots,
    dotProps,
    activeDotProps,
    strokeWidth,
    lineChartProps,
    connectNulls,
    fillOpacity,
    curveType,
    orientation,
    dir,
    valueFormatter,
    children,
    lineProps,
    xAxisLabel,
    yAxisLabel,
    type,
    gradientStops,
    withRightYAxis,
    rightYAxisLabel,
    rightYAxisProps,
    withPointLabels,
    ...others
  } = props;
  const theme = useMantineTheme();
  const withXTickLine = gridAxis !== "none" && (tickLine === "x" || tickLine === "xy");
  const withYTickLine = gridAxis !== "none" && (tickLine === "y" || tickLine === "xy");
  const [highlightedArea, setHighlightedArea] = (0, import_react3.useState)(null);
  const shouldHighlight = highlightedArea !== null;
  const handleMouseLeave = (event) => {
    setHighlightedArea(null);
    onMouseLeave == null ? void 0 : onMouseLeave(event);
  };
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const getStyles = useStyles({
    name: "LineChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver3
  });
  const id = useId();
  const gradientId = `line-chart-gradient-${id}`;
  const stops = gradientStops == null ? void 0 : gradientStops.map((stop) => (0, import_jsx_runtime8.jsx)(
    "stop",
    {
      offset: `${stop.offset}%`,
      stopColor: getThemeColor(stop.color, theme)
    },
    stop.color
  ));
  const lines = series.map((item) => {
    const color = getThemeColor(item.color, theme);
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return (0, import_react3.createElement)(
      Line,
      {
        ...getStyles("line"),
        key: item.name,
        name: item.name,
        dataKey: item.name,
        dot: withDots ? {
          fillOpacity: dimmed ? 0 : 1,
          strokeOpacity: dimmed ? 0 : 1,
          strokeWidth: 1,
          fill: type === "gradient" ? "var(--mantine-color-gray-7)" : color,
          stroke: type === "gradient" ? "white" : color,
          ...dotProps
        } : false,
        activeDot: withDots ? {
          fill: type === "gradient" ? "var(--mantine-color-gray-7)" : color,
          stroke: type === "gradient" ? "white" : color,
          ...activeDotProps
        } : false,
        fill: color,
        stroke: type === "gradient" ? `url(#${gradientId})` : color,
        strokeWidth,
        isAnimationActive: false,
        fillOpacity: dimmed ? 0 : fillOpacity,
        strokeOpacity: dimmed ? 0.5 : fillOpacity,
        connectNulls,
        type: curveType,
        strokeDasharray: item.strokeDasharray,
        yAxisId: item.yAxisId || "left",
        label: withPointLabels ? (0, import_jsx_runtime8.jsx)(PointLabel, { valueFormatter }) : void 0,
        ...typeof lineProps === "function" ? lineProps(item) : lineProps
      }
    );
  });
  const referenceLinesItems = referenceLines == null ? void 0 : referenceLines.map((line, index) => {
    const color = getThemeColor(line.color, theme);
    return (0, import_jsx_runtime8.jsx)(
      ReferenceLine,
      {
        stroke: line.color ? color : "var(--chart-grid-color)",
        strokeWidth: 1,
        yAxisId: line.yAxisId || "left",
        ...line,
        label: {
          value: line.label,
          fill: line.color ? color : "currentColor",
          fontSize: 12,
          position: line.labelPosition ?? "insideBottomLeft"
        },
        ...getStyles("referenceLine")
      },
      index
    );
  });
  const sharedYAxisProps = {
    axisLine: false,
    ...orientation === "vertical" ? { dataKey, type: "category" } : { type: "number" },
    tickLine: withYTickLine ? { stroke: "currentColor" } : false,
    allowDecimals: true,
    unit,
    tickFormatter: orientation === "vertical" ? void 0 : valueFormatter,
    ...getStyles("axis")
  };
  return (0, import_jsx_runtime8.jsx)(
    Box,
    {
      ref,
      ...getStyles("root"),
      onMouseLeave: handleMouseLeave,
      dir: dir || "ltr",
      ...others,
      children: (0, import_jsx_runtime8.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime8.jsxs)(
        LineChart,
        {
          data,
          layout: orientation,
          margin: {
            bottom: xAxisLabel ? 30 : void 0,
            left: yAxisLabel ? 10 : void 0,
            right: yAxisLabel ? 5 : void 0
          },
          ...lineChartProps,
          children: [
            type === "gradient" && (0, import_jsx_runtime8.jsx)("defs", { children: (0, import_jsx_runtime8.jsx)("linearGradient", { id: gradientId, x1: "0", y1: "0", x2: "0", y2: "1", children: stops }) }),
            withLegend && (0, import_jsx_runtime8.jsx)(
              Legend,
              {
                verticalAlign: "top",
                content: (payload) => (0, import_jsx_runtime8.jsx)(
                  ChartLegend,
                  {
                    payload: payload.payload,
                    onHighlight: setHighlightedArea,
                    legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "top",
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    showColor: type !== "gradient"
                  }
                ),
                ...legendProps
              }
            ),
            (0, import_jsx_runtime8.jsxs)(
              XAxis,
              {
                hide: !withXAxis,
                ...orientation === "vertical" ? { type: "number" } : { dataKey },
                tick: { transform: "translate(0, 10)", fontSize: 12, fill: "currentColor" },
                stroke: "",
                interval: "preserveStartEnd",
                tickLine: withXTickLine ? { stroke: "currentColor" } : false,
                minTickGap: 5,
                tickFormatter: orientation === "vertical" ? valueFormatter : void 0,
                ...getStyles("axis"),
                ...xAxisProps,
                children: [
                  xAxisLabel && (0, import_jsx_runtime8.jsx)(Label, { position: "insideBottom", offset: -20, fontSize: 12, ...getStyles("axisLabel"), children: xAxisLabel }),
                  xAxisProps == null ? void 0 : xAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime8.jsxs)(
              YAxis,
              {
                yAxisId: "left",
                orientation: "left",
                tick: { transform: "translate(-10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withYAxis,
                ...sharedYAxisProps,
                ...yAxisProps,
                children: [
                  yAxisLabel && (0, import_jsx_runtime8.jsx)(
                    Label,
                    {
                      position: "insideLeft",
                      angle: -90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: yAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime8.jsxs)(
              YAxis,
              {
                yAxisId: "right",
                orientation: "right",
                tick: { transform: "translate(10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withRightYAxis,
                ...sharedYAxisProps,
                ...rightYAxisProps,
                children: [
                  rightYAxisLabel && (0, import_jsx_runtime8.jsx)(
                    Label,
                    {
                      position: "insideRight",
                      angle: 90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: rightYAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime8.jsx)(
              CartesianGrid,
              {
                strokeDasharray,
                vertical: gridAxis === "y" || gridAxis === "xy",
                horizontal: gridAxis === "x" || gridAxis === "xy",
                ...getStyles("grid"),
                ...gridProps
              }
            ),
            withTooltip && (0, import_jsx_runtime8.jsx)(
              Tooltip,
              {
                animationDuration: tooltipAnimationDuration,
                isAnimationActive: tooltipAnimationDuration !== 0,
                position: orientation === "vertical" ? {} : { y: 0 },
                cursor: {
                  stroke: "var(--chart-grid-color)",
                  strokeWidth: 1,
                  strokeDasharray
                },
                content: ({ label, payload }) => (0, import_jsx_runtime8.jsx)(
                  ChartTooltip,
                  {
                    label,
                    payload,
                    unit,
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    valueFormatter,
                    showColor: type !== "gradient"
                  }
                ),
                ...tooltipProps
              }
            ),
            lines,
            referenceLinesItems,
            children
          ]
        }
      ) })
    }
  );
});
LineChart2.displayName = "@mantine/charts/LineChart";
LineChart2.classes = classes3;

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/Sparkline/Sparkline.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var classes4 = {};
var defaultProps6 = {
  withGradient: true,
  connectNulls: true,
  fillOpacity: 0.6,
  strokeWidth: 2,
  curveType: "linear"
};
function getTrendColor(data, trendColors) {
  const first = data[0];
  const last = data[data.length - 1];
  if (first === null || last === null) {
    return trendColors.neutral || trendColors.positive;
  }
  if (first < last) {
    return trendColors.positive;
  }
  if (first > last) {
    return trendColors.negative;
  }
  return trendColors.neutral || trendColors.positive;
}
var varsResolver4 = createVarsResolver(
  (theme, { color, data, trendColors }) => ({
    root: {
      "--chart-color": trendColors ? getThemeColor(getTrendColor(data, trendColors), theme) : color ? getThemeColor(color, theme) : void 0
    }
  })
);
var Sparkline = factory((_props, ref) => {
  const props = useProps("Sparkline", defaultProps6, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withGradient,
    fillOpacity,
    curveType,
    strokeWidth,
    trendColors,
    connectNulls,
    areaProps,
    ...others
  } = props;
  const getStyles = useStyles({
    name: "Sparkline",
    classes: classes4,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver4
  });
  const id = (0, import_react4.useId)();
  const mappedData = (0, import_react4.useMemo)(() => data.map((value, index) => ({ value, index })), [data]);
  return (0, import_jsx_runtime9.jsx)(Box, { ref, ...getStyles("root"), ...others, dir: "ltr", children: (0, import_jsx_runtime9.jsx)(ResponsiveContainer, { children: (0, import_jsx_runtime9.jsxs)(AreaChart, { data: mappedData, children: [
    (0, import_jsx_runtime9.jsx)(
      Area,
      {
        dataKey: "value",
        type: curveType,
        fill: `url(#${id})`,
        stroke: "var(--chart-color, var(--mantine-color-blue-filled))",
        isAnimationActive: false,
        connectNulls,
        strokeWidth,
        fillOpacity: 1,
        ...areaProps
      }
    ),
    (0, import_jsx_runtime9.jsx)("defs", { children: (0, import_jsx_runtime9.jsx)(
      AreaGradient,
      {
        id,
        color: "var(--chart-color, var(--mantine-color-blue-filled))",
        fillOpacity,
        withGradient
      }
    ) })
  ] }) }) });
});
Sparkline.displayName = "@mantine/charts/Sparkline";
Sparkline.classes = classes4;

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/DonutChart/DonutChart.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/DonutChart/DonutChart.module.css.mjs
var classes5 = { "root": "m_a410e613", "label": "m_ddb0bfe3" };

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/DonutChart/DonutChart.mjs
var defaultProps7 = {
  withTooltip: true,
  withLabelsLine: true,
  paddingAngle: 0,
  thickness: 20,
  size: 160,
  strokeWidth: 1,
  startAngle: 0,
  endAngle: 360,
  labelsType: "value",
  tooltipDataSource: "all"
};
var varsResolver5 = createVarsResolver(
  (theme, { strokeColor, labelColor, withLabels, size }) => ({
    root: {
      "--chart-stroke-color": strokeColor ? getThemeColor(strokeColor, theme) : void 0,
      "--chart-labels-color": labelColor ? getThemeColor(labelColor, theme) : void 0,
      "--chart-size": withLabels ? rem(size + 80) : rem(size)
    }
  })
);
var getLabelValue = (labelsType, value, percent, valueFormatter) => {
  if (labelsType === "percent") {
    return `${(percent * 100).toFixed(0)}%`;
  }
  if (typeof valueFormatter === "function") {
    return valueFormatter(value);
  }
  return value;
};
var getLabel = (labelsType, valueFormatter) => ({ x, y, cx, cy, percent, value }) => (0, import_jsx_runtime10.jsx)(
  "text",
  {
    x,
    y,
    cx,
    cy,
    textAnchor: x > cx ? "start" : "end",
    fill: "var(--chart-labels-color, var(--mantine-color-dimmed))",
    fontFamily: "var(--mantine-font-family)",
    fontSize: 12,
    children: (0, import_jsx_runtime10.jsx)("tspan", { x, children: getLabelValue(labelsType, value, percent, valueFormatter) })
  }
);
var DonutChart = factory((_props, ref) => {
  const props = useProps("DonutChart", defaultProps7, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withTooltip,
    tooltipAnimationDuration,
    tooltipProps,
    pieProps,
    paddingAngle,
    withLabels,
    withLabelsLine,
    size,
    thickness,
    strokeWidth,
    startAngle,
    endAngle,
    tooltipDataSource,
    chartLabel,
    children,
    pieChartProps,
    valueFormatter,
    strokeColor,
    labelsType,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "DonutChart",
    classes: classes5,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver5
  });
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const cells = data.map((item, index) => (0, import_jsx_runtime10.jsx)(
    Cell,
    {
      fill: getThemeColor(item.color, theme),
      stroke: "var(--chart-stroke-color, var(--mantine-color-body))",
      strokeWidth
    },
    index
  ));
  return (0, import_jsx_runtime10.jsx)(Box, { ref, size, ...getStyles("root"), ...others, children: (0, import_jsx_runtime10.jsx)(ResponsiveContainer, { children: (0, import_jsx_runtime10.jsxs)(PieChart, { ...pieChartProps, children: [
    (0, import_jsx_runtime10.jsx)(
      Pie,
      {
        data,
        innerRadius: size / 2 - thickness,
        outerRadius: size / 2,
        dataKey: "value",
        isAnimationActive: false,
        paddingAngle,
        startAngle,
        endAngle,
        label: withLabels ? getLabel(labelsType || "value", valueFormatter) : false,
        labelLine: withLabelsLine ? {
          stroke: "var(--chart-label-color, var(--mantine-color-dimmed))",
          strokeWidth: 1
        } : false,
        ...pieProps,
        children: cells
      }
    ),
    chartLabel && (0, import_jsx_runtime10.jsx)(
      "text",
      {
        x: "50%",
        y: "50%",
        textAnchor: "middle",
        dominantBaseline: "middle",
        ...getStyles("label"),
        children: chartLabel
      }
    ),
    withTooltip && (0, import_jsx_runtime10.jsx)(
      Tooltip,
      {
        animationDuration: tooltipAnimationDuration,
        isAnimationActive: false,
        content: ({ payload }) => {
          var _a;
          return (0, import_jsx_runtime10.jsx)(
            ChartTooltip,
            {
              payload: data,
              classNames: resolvedClassNames,
              styles: resolvedStyles,
              type: "radial",
              segmentId: tooltipDataSource === "segment" ? (_a = payload == null ? void 0 : payload[0]) == null ? void 0 : _a.name : void 0,
              valueFormatter
            }
          );
        },
        ...tooltipProps
      }
    ),
    children
  ] }) }) });
});
DonutChart.displayName = "@mantine/charts/DonutChart";
DonutChart.classes = classes5;

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/PieChart/PieChart.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/PieChart/PieChart.module.css.mjs
var classes6 = { "root": "m_cd8943fd" };

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/PieChart/PieChart.mjs
var defaultProps8 = {
  withTooltip: false,
  withLabelsLine: true,
  paddingAngle: 0,
  size: 160,
  strokeWidth: 1,
  startAngle: 0,
  endAngle: 360,
  tooltipDataSource: "all",
  labelsPosition: "outside",
  labelsType: "value"
};
var varsResolver6 = createVarsResolver(
  (theme, { strokeColor, labelColor, withLabels, size, labelsPosition }) => ({
    root: {
      "--chart-stroke-color": strokeColor ? getThemeColor(strokeColor, theme) : void 0,
      "--chart-labels-color": labelColor ? getThemeColor(labelColor, theme) : void 0,
      "--chart-size": withLabels && labelsPosition === "outside" ? rem(size + 80) : rem(size)
    }
  })
);
var getLabelValue2 = (labelsType, value, percent, valueFormatter) => {
  if (labelsType === "percent") {
    return `${(percent * 100).toFixed(0)}%`;
  }
  if (typeof valueFormatter === "function") {
    return valueFormatter(value);
  }
  return value;
};
var getInsideLabel = (labelsType, valueFormatter) => ({ cx, cy, midAngle, innerRadius, outerRadius, value, percent }) => {
  const RADIAN = Math.PI / 180;
  const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
  const x = cx + radius * Math.cos(-midAngle * RADIAN);
  const y = cy + radius * Math.sin(-midAngle * RADIAN);
  return (0, import_jsx_runtime11.jsx)(
    "text",
    {
      x,
      y,
      textAnchor: x > cx ? "start" : "end",
      dominantBaseline: "central",
      className: classes6.label,
      children: getLabelValue2(labelsType, value, percent, valueFormatter)
    }
  );
};
var getOutsideLabel = (labelsType, valueFormatter) => ({ x, y, cx, cy, percent, value }) => (0, import_jsx_runtime11.jsx)(
  "text",
  {
    x,
    y,
    cx,
    cy,
    textAnchor: x > cx ? "start" : "end",
    fill: "var(--chart-labels-color, var(--mantine-color-dimmed))",
    fontFamily: "var(--mantine-font-family)",
    fontSize: 12,
    children: (0, import_jsx_runtime11.jsx)("tspan", { x, children: getLabelValue2(labelsType, value, percent, valueFormatter) })
  }
);
var PieChart2 = factory((_props, ref) => {
  const props = useProps("PieChart", defaultProps8, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withTooltip,
    tooltipAnimationDuration,
    tooltipProps,
    pieProps,
    paddingAngle,
    withLabels,
    withLabelsLine,
    size,
    strokeWidth,
    startAngle,
    endAngle,
    tooltipDataSource,
    children,
    pieChartProps,
    labelsPosition,
    valueFormatter,
    labelsType,
    strokeColor,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "PieChart",
    classes: classes6,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver6
  });
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const cells = data.map((item, index) => (0, import_jsx_runtime11.jsx)(
    Cell,
    {
      fill: getThemeColor(item.color, theme),
      stroke: "var(--chart-stroke-color, var(--mantine-color-body))",
      strokeWidth
    },
    index
  ));
  return (0, import_jsx_runtime11.jsx)(Box, { ref, size, ...getStyles("root"), ...others, children: (0, import_jsx_runtime11.jsx)(ResponsiveContainer, { children: (0, import_jsx_runtime11.jsxs)(PieChart, { ...pieChartProps, children: [
    (0, import_jsx_runtime11.jsx)(
      Pie,
      {
        data,
        innerRadius: 0,
        outerRadius: size / 2,
        dataKey: "value",
        isAnimationActive: false,
        paddingAngle,
        startAngle,
        endAngle,
        label: withLabels ? labelsPosition === "inside" ? getInsideLabel(labelsType || "value", valueFormatter) : getOutsideLabel(labelsType || "value", valueFormatter) : false,
        labelLine: withLabelsLine && labelsPosition === "outside" ? {
          stroke: "var(--chart-label-color, var(--mantine-color-dimmed))",
          strokeWidth: 1
        } : false,
        ...pieProps,
        children: cells
      }
    ),
    withTooltip && (0, import_jsx_runtime11.jsx)(
      Tooltip,
      {
        animationDuration: tooltipAnimationDuration,
        isAnimationActive: false,
        content: ({ payload }) => {
          var _a;
          return (0, import_jsx_runtime11.jsx)(
            ChartTooltip,
            {
              payload: data,
              classNames: resolvedClassNames,
              styles: resolvedStyles,
              type: "radial",
              segmentId: tooltipDataSource === "segment" ? (_a = payload == null ? void 0 : payload[0]) == null ? void 0 : _a.name : void 0,
              valueFormatter
            }
          );
        },
        ...tooltipProps
      }
    ),
    children
  ] }) }) });
});
PieChart2.displayName = "@mantine/charts/PieChart";
PieChart2.classes = classes6;

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/RadarChart/RadarChart.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/RadarChart/RadarChart.module.css.mjs
var classes7 = { "root": "m_1f271cf7", "container": "m_cf06f58c" };

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/RadarChart/RadarChart.mjs
var defaultProps9 = {
  withPolarGrid: true,
  withPolarAngleAxis: true,
  withPolarRadiusAxis: false
};
var varsResolver7 = createVarsResolver((theme, { gridColor, textColor }) => ({
  root: {
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0,
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0
  }
}));
var RadarChart2 = factory((_props, ref) => {
  const props = useProps("RadarChart", defaultProps9, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    series,
    dataKey,
    gridColor,
    textColor,
    radarProps,
    radarChartProps,
    polarGridProps,
    polarAngleAxisProps,
    polarRadiusAxisProps,
    withPolarGrid,
    withPolarAngleAxis,
    withPolarRadiusAxis,
    children,
    withLegend,
    legendProps,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "RadarChart",
    classes: classes7,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver7
  });
  const [highlightedArea, setHighlightedArea] = (0, import_react5.useState)(null);
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const radars = series.map((item, index) => (0, import_jsx_runtime12.jsx)(
    Radar,
    {
      name: item.name,
      dataKey: item.name,
      stroke: getThemeColor(item.strokeColor || item.color, theme),
      fill: getThemeColor(item.color, theme),
      fillOpacity: highlightedArea ? highlightedArea === item.name ? item.opacity || 0.4 : 0.05 : item.opacity || 0.4,
      strokeOpacity: highlightedArea ? highlightedArea === item.name ? 1 : 0.1 : 1,
      isAnimationActive: false,
      ...typeof radarProps === "function" ? radarProps(item) : radarProps
    },
    index
  ));
  return (0, import_jsx_runtime12.jsx)(Box, { ref, ...getStyles("root"), ...others, children: (0, import_jsx_runtime12.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime12.jsxs)(RadarChart, { data, ...radarChartProps, children: [
    withPolarGrid && (0, import_jsx_runtime12.jsx)(PolarGrid, { stroke: "var(--chart-grid-color)", ...polarGridProps }),
    withPolarAngleAxis && (0, import_jsx_runtime12.jsx)(PolarAngleAxis, { dataKey, ...polarAngleAxisProps }),
    withPolarRadiusAxis && (0, import_jsx_runtime12.jsx)(PolarRadiusAxis, { stroke: "var(--chart-grid-color)", ...polarRadiusAxisProps }),
    radars,
    withLegend && (0, import_jsx_runtime12.jsx)(
      Legend,
      {
        verticalAlign: "bottom",
        content: (payload) => (0, import_jsx_runtime12.jsx)(
          ChartLegend,
          {
            payload: payload.payload,
            onHighlight: setHighlightedArea,
            legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "bottom",
            classNames: resolvedClassNames,
            styles: resolvedStyles,
            series,
            centered: true
          }
        ),
        ...legendProps
      }
    ),
    children
  ] }) }) });
});
RadarChart2.displayName = "@mantine/charts/RadarChart";
RadarChart2.classes = classes7;

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/ScatterChart/ScatterChart.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
function getAxis(key, dataKey) {
  return key === dataKey.x ? "x" : "y";
}
var defaultProps10 = {
  withXAxis: true,
  withYAxis: true,
  withTooltip: true,
  tooltipAnimationDuration: 0,
  tickLine: "y",
  strokeDasharray: "5 5",
  gridAxis: "x"
};
var varsResolver8 = createVarsResolver((theme, { textColor, gridColor }) => ({
  root: {
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0
  }
}));
var ScatterChart2 = factory((_props, ref) => {
  const props = useProps("ScatterChart", defaultProps10, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    referenceLines,
    dir,
    withLegend,
    withTooltip,
    withXAxis,
    withYAxis,
    xAxisProps,
    yAxisProps,
    orientation,
    scatterChartProps,
    legendProps,
    data,
    gridAxis,
    tickLine,
    strokeDasharray,
    gridProps,
    tooltipAnimationDuration,
    tooltipProps,
    children,
    onMouseLeave,
    dataKey,
    textColor,
    gridColor,
    xAxisLabel,
    yAxisLabel,
    unit,
    labels,
    valueFormatter,
    scatterProps,
    pointLabels,
    ...others
  } = props;
  const getFormatter = (axis) => typeof valueFormatter === "function" ? valueFormatter : valueFormatter == null ? void 0 : valueFormatter[axis];
  const xFormatter = getFormatter("x");
  const yFormatter = getFormatter("y");
  const theme = useMantineTheme();
  const mappedData = data.map((item) => ({
    ...item,
    data: item.data.map((point) => ({ ...point, name: item.name }))
  }));
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const getStyles = useStyles({
    name: "ScatterChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver8
  });
  const withXTickLine = gridAxis !== "none" && (tickLine === "x" || tickLine === "xy");
  const withYTickLine = gridAxis !== "none" && (tickLine === "y" || tickLine === "xy");
  const [highlightedArea, setHighlightedArea] = (0, import_react6.useState)(null);
  const shouldHighlight = highlightedArea !== null;
  const handleMouseLeave = (event) => {
    setHighlightedArea(null);
    onMouseLeave == null ? void 0 : onMouseLeave(event);
  };
  const referenceLinesItems = referenceLines == null ? void 0 : referenceLines.map((line, index) => {
    const color = getThemeColor(line.color, theme);
    return (0, import_jsx_runtime13.jsx)(
      ReferenceLine,
      {
        stroke: line.color ? color : "var(--chart-grid-color)",
        strokeWidth: 1,
        ...line,
        label: {
          value: line.label,
          fill: line.color ? color : "currentColor",
          fontSize: 12,
          position: line.labelPosition ?? "insideBottomLeft"
        },
        ...getStyles("referenceLine")
      },
      index
    );
  });
  const scatters = mappedData.map((item, index) => {
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return (0, import_jsx_runtime13.jsxs)(
      Scatter,
      {
        data: item.data,
        fill: getThemeColor(item.color, theme),
        isAnimationActive: false,
        fillOpacity: dimmed ? 0.1 : 1,
        ...scatterProps,
        children: [
          pointLabels && (0, import_jsx_runtime13.jsx)(LabelList, { dataKey: dataKey[pointLabels], fontSize: 8, dy: 10 }),
          scatterProps == null ? void 0 : scatterProps.children
        ]
      },
      index
    );
  });
  return (0, import_jsx_runtime13.jsx)(
    Box,
    {
      ref,
      ...getStyles("root"),
      onMouseLeave: handleMouseLeave,
      dir: dir || "ltr",
      ...others,
      children: (0, import_jsx_runtime13.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime13.jsxs)(
        ScatterChart,
        {
          margin: {
            bottom: xAxisLabel ? 30 : void 0,
            left: yAxisLabel ? 10 : void 0,
            right: yAxisLabel ? 5 : void 0
          },
          ...scatterChartProps,
          children: [
            (0, import_jsx_runtime13.jsx)(
              CartesianGrid,
              {
                strokeDasharray,
                vertical: gridAxis === "y" || gridAxis === "xy",
                horizontal: gridAxis === "x" || gridAxis === "xy",
                ...getStyles("grid"),
                ...gridProps
              }
            ),
            (0, import_jsx_runtime13.jsxs)(
              XAxis,
              {
                type: "number",
                hide: !withXAxis,
                dataKey: dataKey.x,
                tick: { transform: "translate(0, 10)", fontSize: 12, fill: "currentColor" },
                stroke: "",
                interval: "preserveStartEnd",
                tickLine: withXTickLine ? { stroke: "currentColor" } : false,
                minTickGap: 5,
                unit: unit == null ? void 0 : unit.x,
                tickFormatter: xFormatter,
                ...getStyles("axis"),
                ...xAxisProps,
                children: [
                  xAxisLabel && (0, import_jsx_runtime13.jsx)(Label, { position: "insideBottom", offset: -20, fontSize: 12, ...getStyles("axisLabel"), children: xAxisLabel }),
                  xAxisProps == null ? void 0 : xAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime13.jsxs)(
              YAxis,
              {
                type: "number",
                hide: !withYAxis,
                axisLine: false,
                dataKey: dataKey.y,
                tickLine: withYTickLine ? { stroke: "currentColor" } : false,
                tick: { transform: "translate(-10, 0)", fontSize: 12, fill: "currentColor" },
                allowDecimals: true,
                unit: unit == null ? void 0 : unit.y,
                tickFormatter: yFormatter,
                ...getStyles("axis"),
                ...yAxisProps,
                children: [
                  yAxisLabel && (0, import_jsx_runtime13.jsx)(
                    Label,
                    {
                      position: "insideLeft",
                      angle: -90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: yAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            withTooltip && (0, import_jsx_runtime13.jsx)(
              Tooltip,
              {
                animationDuration: tooltipAnimationDuration,
                isAnimationActive: tooltipAnimationDuration !== 0,
                position: { y: 0 },
                cursor: {
                  stroke: "var(--chart-grid-color)",
                  strokeWidth: 1,
                  strokeDasharray
                },
                content: ({ label, payload }) => (0, import_jsx_runtime13.jsx)(
                  ChartTooltip,
                  {
                    type: "scatter",
                    label,
                    payload: labels ? payload == null ? void 0 : payload.map((item) => {
                      var _a;
                      return {
                        ...item,
                        name: labels[getAxis(item.name, dataKey)] || item.name,
                        value: ((_a = getFormatter(getAxis(item.name, dataKey))) == null ? void 0 : _a(item.value)) ?? item.value
                      };
                    }) : payload == null ? void 0 : payload.map((item) => {
                      var _a;
                      return {
                        ...item,
                        value: ((_a = getFormatter(getAxis(item.name, dataKey))) == null ? void 0 : _a(item.value)) ?? item.value
                      };
                    }),
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series: data
                  }
                ),
                ...tooltipProps
              }
            ),
            withLegend && (0, import_jsx_runtime13.jsx)(
              Legend,
              {
                verticalAlign: "top",
                content: (payload) => {
                  var _a;
                  return (0, import_jsx_runtime13.jsx)(
                    ChartLegend,
                    {
                      payload: (_a = payload.payload) == null ? void 0 : _a.map((item, index) => ({
                        ...item,
                        dataKey: data[index].name
                      })),
                      onHighlight: setHighlightedArea,
                      legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "top",
                      classNames: resolvedClassNames,
                      styles: resolvedStyles,
                      series: data
                    }
                  );
                },
                height: 44,
                ...legendProps
              }
            ),
            referenceLinesItems,
            scatters
          ]
        }
      ) })
    }
  );
});
ScatterChart2.displayName = "@mantine/charts/ScatterChart";
ScatterChart2.classes = classes3;

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/BubbleChart/BubbleChart.mjs
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function getDomain(data, key) {
  const values = data.map((item) => item[key]);
  return [Math.min(...values), Math.max(...values)];
}
function BubbleChartTooltip({
  active,
  payload,
  getStyles,
  dataKey,
  valueFormatter
}) {
  if (active && payload && payload.length) {
    const data = payload[0] && payload[0].payload;
    return (0, import_jsx_runtime14.jsx)("div", { ...getStyles("tooltip"), children: (0, import_jsx_runtime14.jsxs)(Group, { justify: "space-between", children: [
      (0, import_jsx_runtime14.jsx)(Text, { fz: "sm", children: data[dataKey.x] }),
      (0, import_jsx_runtime14.jsx)(Text, { fz: "sm", children: valueFormatter ? valueFormatter(data[dataKey.z]) : data[dataKey.z] })
    ] }) });
  }
  return null;
}
var defaultProps11 = {
  color: "blue.6",
  withTooltip: true
};
var varsResolver9 = createVarsResolver((theme, { textColor, gridColor }) => ({
  root: {
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0
  }
}));
var BubbleChart = factory((_props, ref) => {
  const props = useProps("BubbleChart", defaultProps11, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    xAxisProps,
    yAxisProps,
    zAxisProps,
    tooltipProps,
    scatterProps,
    color,
    label,
    withTooltip,
    dataKey,
    range,
    valueFormatter,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "BubbleChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver9
  });
  return (0, import_jsx_runtime14.jsx)(Box, { ref, ...getStyles("root"), ...others, children: (0, import_jsx_runtime14.jsx)(ResponsiveContainer, { children: (0, import_jsx_runtime14.jsxs)(ScatterChart, { children: [
    (0, import_jsx_runtime14.jsx)(
      XAxis,
      {
        type: "category",
        dataKey: dataKey.x,
        interval: 0,
        tick: { fontSize: 12, fill: "currentColor" },
        tickLine: { transform: "translate(0, -6)", stroke: "currentColor" },
        stroke: "currentColor",
        ...getStyles("axis"),
        ...xAxisProps
      }
    ),
    (0, import_jsx_runtime14.jsx)(
      YAxis,
      {
        type: "number",
        dataKey: dataKey.y,
        height: 10,
        width: label ? void 0 : 0,
        tick: false,
        tickLine: false,
        axisLine: false,
        label: { value: label, position: "insideRight", fontSize: 12, fill: "currentColor" },
        ...getStyles("axis"),
        ...yAxisProps
      }
    ),
    (0, import_jsx_runtime14.jsx)(
      ZAxis,
      {
        type: "number",
        dataKey: dataKey.z,
        domain: getDomain(data, dataKey.z),
        range,
        ...zAxisProps
      }
    ),
    withTooltip && (0, import_jsx_runtime14.jsx)(
      Tooltip,
      {
        animationDuration: 100,
        isAnimationActive: false,
        cursor: { stroke: "var(--chart-grid-color)", strokeWidth: 1, strokeDasharray: "3 3" },
        content: (payload) => (0, import_jsx_runtime14.jsx)(
          BubbleChartTooltip,
          {
            dataKey,
            active: payload.active,
            payload: payload.payload,
            getStyles,
            valueFormatter
          }
        ),
        ...tooltipProps
      }
    ),
    (0, import_jsx_runtime14.jsx)(
      Scatter,
      {
        data,
        fill: getThemeColor(color, theme),
        isAnimationActive: false,
        ...scatterProps
      }
    )
  ] }) }) });
});
BubbleChart.displayName = "@mantine/charts/BubbleChart";
BubbleChart.classes = classes3;

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/CompositeChart/CompositeChart.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var defaultProps12 = {
  withXAxis: true,
  withYAxis: true,
  withTooltip: true,
  tooltipAnimationDuration: 0,
  tickLine: "y",
  strokeDasharray: "5 5",
  gridAxis: "x",
  withDots: true,
  connectNulls: true,
  strokeWidth: 2,
  curveType: "monotone"
};
var varsResolver10 = createVarsResolver(
  (theme, { textColor, gridColor }) => ({
    root: {
      "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
      "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0
    }
  })
);
var CompositeChart = factory((_props, ref) => {
  const props = useProps("CompositeChart", defaultProps12, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withLegend,
    legendProps,
    series,
    onMouseLeave,
    dataKey,
    withTooltip,
    withXAxis,
    withYAxis,
    gridAxis,
    tickLine,
    xAxisProps,
    yAxisProps,
    unit,
    tooltipAnimationDuration,
    strokeDasharray,
    gridProps,
    tooltipProps,
    referenceLines,
    withDots,
    dotProps,
    activeDotProps,
    strokeWidth,
    connectNulls,
    curveType,
    dir,
    valueFormatter,
    children,
    lineProps,
    xAxisLabel,
    yAxisLabel,
    withRightYAxis,
    rightYAxisLabel,
    rightYAxisProps,
    withPointLabels,
    areaProps,
    barProps,
    withBarValueLabel,
    minBarSize,
    maxBarWidth,
    composedChartProps,
    ...others
  } = props;
  const theme = useMantineTheme();
  const withXTickLine = gridAxis !== "none" && (tickLine === "x" || tickLine === "xy");
  const withYTickLine = gridAxis !== "none" && (tickLine === "y" || tickLine === "xy");
  const [highlightedArea, setHighlightedArea] = (0, import_react7.useState)(null);
  const shouldHighlight = highlightedArea !== null;
  const handleMouseLeave = (event) => {
    setHighlightedArea(null);
    onMouseLeave == null ? void 0 : onMouseLeave(event);
  };
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const getStyles = useStyles({
    name: "CompositeChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver10
  });
  const lines = series.map((item) => {
    const color = getThemeColor(item.color, theme);
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    if (item.type === "line") {
      return (0, import_react7.createElement)(
        Line,
        {
          ...getStyles("line"),
          key: item.name,
          name: item.name,
          dataKey: item.name,
          dot: withDots ? {
            fillOpacity: dimmed ? 0 : 1,
            strokeOpacity: dimmed ? 0 : 1,
            strokeWidth: 1,
            fill: color,
            stroke: color,
            ...dotProps
          } : false,
          activeDot: withDots ? { fill: "var(--mantine-color-white)", stroke: color, ...activeDotProps } : false,
          fill: color,
          stroke: color,
          strokeWidth,
          isAnimationActive: false,
          fillOpacity: dimmed ? 0 : 1,
          strokeOpacity: dimmed ? 0.5 : 1,
          connectNulls,
          type: curveType,
          strokeDasharray: item.strokeDasharray,
          yAxisId: item.yAxisId || "left",
          label: withPointLabels ? (0, import_jsx_runtime15.jsx)(PointLabel, { valueFormatter }) : void 0,
          ...typeof lineProps === "function" ? lineProps(item) : lineProps
        }
      );
    }
    if (item.type === "area") {
      return (0, import_react7.createElement)(
        Area,
        {
          ...getStyles("area"),
          key: item.name,
          name: item.name,
          type: curveType,
          dataKey: item.name,
          fill: color,
          strokeWidth,
          stroke: color,
          isAnimationActive: false,
          connectNulls,
          dot: withDots ? {
            fillOpacity: dimmed ? 0 : 1,
            strokeOpacity: dimmed ? 0 : 1,
            strokeWidth: 1,
            fill: color,
            stroke: color,
            ...dotProps
          } : false,
          activeDot: withDots ? {
            fill: theme.white,
            stroke: color,
            strokeWidth: 2,
            r: 4,
            ...activeDotProps
          } : false,
          fillOpacity: dimmed ? 0 : 0.2,
          strokeOpacity: dimmed ? 0.5 : 1,
          strokeDasharray: item.strokeDasharray,
          yAxisId: item.yAxisId || "left",
          label: withPointLabels ? (0, import_jsx_runtime15.jsx)(PointLabel, { valueFormatter }) : void 0,
          ...typeof areaProps === "function" ? areaProps(item) : areaProps
        }
      );
    }
    if (item.type === "bar") {
      return (0, import_react7.createElement)(
        Bar,
        {
          ...getStyles("bar"),
          key: item.name,
          name: item.name,
          dataKey: item.name,
          fill: color,
          stroke: color,
          isAnimationActive: false,
          fillOpacity: dimmed ? 0.1 : 1,
          strokeOpacity: dimmed ? 0.2 : 0,
          yAxisId: item.yAxisId || "left",
          minPointSize: minBarSize,
          ...typeof barProps === "function" ? barProps(item) : barProps
        },
        withBarValueLabel && (0, import_jsx_runtime15.jsx)(
          LabelList,
          {
            position: "top",
            fontSize: 12,
            fill: "var(--chart-bar-label-color, var(--mantine-color-dimmed))",
            formatter: valueFormatter
          }
        )
      );
    }
    return null;
  });
  const referenceLinesItems = referenceLines == null ? void 0 : referenceLines.map((line, index) => {
    const color = getThemeColor(line.color, theme);
    return (0, import_jsx_runtime15.jsx)(
      ReferenceLine,
      {
        stroke: line.color ? color : "var(--chart-grid-color)",
        strokeWidth: 1,
        yAxisId: line.yAxisId || "left",
        ...line,
        label: {
          value: line.label,
          fill: line.color ? color : "currentColor",
          fontSize: 12,
          position: line.labelPosition ?? "insideBottomLeft"
        },
        ...getStyles("referenceLine")
      },
      index
    );
  });
  const sharedYAxisProps = {
    axisLine: false,
    type: "number",
    tickLine: withYTickLine ? { stroke: "currentColor" } : false,
    allowDecimals: true,
    unit,
    tickFormatter: valueFormatter,
    ...getStyles("axis")
  };
  return (0, import_jsx_runtime15.jsx)(
    Box,
    {
      ref,
      ...getStyles("root"),
      onMouseLeave: handleMouseLeave,
      dir: dir || "ltr",
      ...others,
      children: (0, import_jsx_runtime15.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime15.jsxs)(
        ComposedChart,
        {
          data,
          maxBarSize: maxBarWidth,
          margin: {
            bottom: xAxisLabel ? 30 : void 0,
            left: yAxisLabel ? 10 : void 0,
            right: yAxisLabel ? 5 : void 0
          },
          ...composedChartProps,
          children: [
            withLegend && (0, import_jsx_runtime15.jsx)(
              Legend,
              {
                verticalAlign: "top",
                content: (payload) => (0, import_jsx_runtime15.jsx)(
                  ChartLegend,
                  {
                    payload: payload.payload,
                    onHighlight: setHighlightedArea,
                    legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "top",
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series
                  }
                ),
                ...legendProps
              }
            ),
            (0, import_jsx_runtime15.jsxs)(
              XAxis,
              {
                hide: !withXAxis,
                dataKey,
                tick: { transform: "translate(0, 10)", fontSize: 12, fill: "currentColor" },
                stroke: "",
                interval: "preserveStartEnd",
                tickLine: withXTickLine ? { stroke: "currentColor" } : false,
                minTickGap: 5,
                ...getStyles("axis"),
                ...xAxisProps,
                children: [
                  xAxisLabel && (0, import_jsx_runtime15.jsx)(Label, { position: "insideBottom", offset: -20, fontSize: 12, ...getStyles("axisLabel"), children: xAxisLabel }),
                  xAxisProps == null ? void 0 : xAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime15.jsxs)(
              YAxis,
              {
                yAxisId: "left",
                orientation: "left",
                tick: { transform: "translate(-10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withYAxis,
                ...sharedYAxisProps,
                ...yAxisProps,
                children: [
                  yAxisLabel && (0, import_jsx_runtime15.jsx)(
                    Label,
                    {
                      position: "insideLeft",
                      angle: -90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: yAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime15.jsxs)(
              YAxis,
              {
                yAxisId: "right",
                orientation: "right",
                tick: { transform: "translate(10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withRightYAxis,
                ...sharedYAxisProps,
                ...rightYAxisProps,
                children: [
                  rightYAxisLabel && (0, import_jsx_runtime15.jsx)(
                    Label,
                    {
                      position: "insideRight",
                      angle: 90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: rightYAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime15.jsx)(
              CartesianGrid,
              {
                strokeDasharray,
                vertical: gridAxis === "y" || gridAxis === "xy",
                horizontal: gridAxis === "x" || gridAxis === "xy",
                ...getStyles("grid"),
                ...gridProps
              }
            ),
            withTooltip && (0, import_jsx_runtime15.jsx)(
              Tooltip,
              {
                animationDuration: tooltipAnimationDuration,
                isAnimationActive: tooltipAnimationDuration !== 0,
                position: { y: 0 },
                cursor: {
                  stroke: "var(--chart-grid-color)",
                  strokeWidth: 1,
                  strokeDasharray
                },
                content: ({ label, payload }) => (0, import_jsx_runtime15.jsx)(
                  ChartTooltip,
                  {
                    label,
                    payload,
                    unit,
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    valueFormatter
                  }
                ),
                ...tooltipProps
              }
            ),
            lines,
            referenceLinesItems,
            children
          ]
        }
      ) })
    }
  );
});
CompositeChart.displayName = "@mantine/charts/CompositeChart";
CompositeChart.classes = classes3;

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/RadialBarChart/RadialBarChart.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/RadialBarChart/RadialBarChart.module.css.mjs
var classes8 = { "root": "m_cd2bd9e5", "tooltip": "m_6bcc3420" };

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/RadialBarChart/RadialBarChart.mjs
var defaultProps13 = {
  barSize: 20,
  startAngle: 90,
  endAngle: -270,
  withBackground: true,
  withTooltip: true
};
var varsResolver11 = createVarsResolver(
  (theme, { emptyBackgroundColor }) => ({
    root: {
      "--chart-empty-background": emptyBackgroundColor ? getThemeColor(emptyBackgroundColor, theme) : void 0
    }
  })
);
var RadialBarChart2 = factory((_props, ref) => {
  const props = useProps("RadialBarChart", defaultProps13, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    barSize,
    withBackground,
    dataKey,
    radialBarProps,
    radialBarChartProps,
    withLabels,
    withLegend,
    legendProps,
    withTooltip,
    tooltipProps,
    startAngle,
    endAngle,
    ...others
  } = props;
  const [highlightedArea, setHighlightedArea] = (0, import_react8.useState)(null);
  const getStyles = useStyles({
    name: "RadialBarChart",
    classes: classes8,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver11
  });
  const theme = useMantineTheme();
  const dataWithResolvedColor = data.map(({ color, ...item }) => {
    const resolvedColor = getThemeColor(color, theme);
    return {
      ...item,
      fill: resolvedColor,
      fillOpacity: highlightedArea ? highlightedArea === item.name ? item.opacity || 1 : 0.05 : item.opacity || 1
    };
  });
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return (0, import_jsx_runtime16.jsx)(Box, { ref, ...getStyles("root"), ...others, children: (0, import_jsx_runtime16.jsx)(ResponsiveContainer, { children: (0, import_jsx_runtime16.jsxs)(
    RadialBarChart,
    {
      margin: { top: 0, bottom: 0, left: 0, right: 0 },
      innerRadius: "10%",
      outerRadius: "100%",
      cx: "50%",
      cy: "50%",
      barSize,
      startAngle,
      endAngle,
      data: dataWithResolvedColor,
      ...radialBarChartProps,
      children: [
        (0, import_jsx_runtime16.jsx)(
          RadialBar,
          {
            label: withLabels ? {
              position: "insideStart",
              fill: "var(--mantine-color-white)",
              fontSize: 12
            } : void 0,
            background: withBackground ? { fill: "var(--chart-empty-background)" } : void 0,
            dataKey,
            isAnimationActive: false,
            ...radialBarProps
          }
        ),
        withLegend && (0, import_jsx_runtime16.jsx)(
          Legend,
          {
            verticalAlign: "bottom",
            content: (payload) => {
              var _a;
              return (0, import_jsx_runtime16.jsx)(
                ChartLegend,
                {
                  payload: (_a = payload.payload) == null ? void 0 : _a.map((item) => {
                    var _a2;
                    return {
                      ...item,
                      dataKey: (_a2 = item.payload) == null ? void 0 : _a2.name
                    };
                  }),
                  onHighlight: setHighlightedArea,
                  legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "bottom",
                  classNames: resolvedClassNames,
                  styles: resolvedStyles,
                  centered: true
                }
              );
            },
            ...legendProps
          }
        ),
        withTooltip && (0, import_jsx_runtime16.jsx)(
          Tooltip,
          {
            animationDuration: 0,
            isAnimationActive: false,
            cursor: { stroke: "var(--chart-cursor-color)" },
            content: ({ payload }) => {
              var _a, _b, _c;
              return (0, import_jsx_runtime16.jsxs)(Paper, { ...getStyles("tooltip"), children: [
                (0, import_jsx_runtime16.jsxs)(Group, { gap: "sm", children: [
                  (0, import_jsx_runtime16.jsx)(ColorSwatch, { color: (_a = payload == null ? void 0 : payload[0]) == null ? void 0 : _a.payload.fill, size: 12, withShadow: false }),
                  (0, import_jsx_runtime16.jsx)("span", { children: (_b = payload == null ? void 0 : payload[0]) == null ? void 0 : _b.payload.name })
                ] }),
                (0, import_jsx_runtime16.jsx)("span", { children: (_c = payload == null ? void 0 : payload[0]) == null ? void 0 : _c.payload[dataKey] })
              ] });
            },
            ...tooltipProps
          }
        )
      ]
    }
  ) }) });
});
RadialBarChart2.displayName = "@mantine/core/RadialBarChart";
RadialBarChart2.classes = classes8;

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/FunnelChart/FunnelChart.mjs
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/FunnelChart/FunnelChart.module.css.mjs
var classes9 = { "root": "m_80d531e7" };

// node_modules/.deno/@mantine+charts@7.15.2/node_modules/@mantine/charts/esm/FunnelChart/FunnelChart.mjs
var defaultProps14 = {
  withTooltip: true,
  size: 300,
  strokeWidth: 1,
  withLabels: false,
  labelsPosition: "right",
  tooltipDataSource: "all"
};
var varsResolver12 = createVarsResolver(
  (theme, { strokeColor, labelColor, size }) => ({
    root: {
      "--chart-stroke-color": strokeColor ? getThemeColor(strokeColor, theme) : void 0,
      "--chart-labels-color": labelColor ? getThemeColor(labelColor, theme) : void 0,
      "--chart-size": rem(size)
    }
  })
);
var FunnelChart2 = factory((_props, ref) => {
  const props = useProps("FunnelChart", defaultProps14, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withTooltip,
    tooltipAnimationDuration,
    tooltipProps,
    strokeWidth,
    withLabels,
    size,
    valueFormatter,
    children,
    funnelChartProps,
    funnelProps,
    labelsPosition,
    tooltipDataSource,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "FunnelChart",
    classes: classes9,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver12
  });
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return (0, import_jsx_runtime17.jsx)(Box, { ref, size, ...getStyles("root"), ...others, children: (0, import_jsx_runtime17.jsx)(ResponsiveContainer, { children: (0, import_jsx_runtime17.jsxs)(FunnelChart, { ...funnelChartProps, children: [
    (0, import_jsx_runtime17.jsxs)(
      Funnel,
      {
        data,
        dataKey: "value",
        isAnimationActive: false,
        stroke: "var(--chart-stroke-color, var(--mantine-color-body))",
        strokeWidth,
        ...funnelProps,
        children: [
          withLabels && (0, import_jsx_runtime17.jsx)(
            LabelList,
            {
              position: labelsPosition,
              fill: labelsPosition === "inside" ? "var(--chart-labels-color, var(--mantine-color-white))" : "var(--chart-labels-color, var(--mantine-color-dimmed))",
              stroke: "none",
              fontFamily: "var(--mantine-font-family)",
              fontSize: 14,
              dataKey: (entry) => {
                return typeof valueFormatter === "function" ? valueFormatter(entry.value) : entry.value;
              }
            }
          ),
          data.map((entry, index) => (0, import_jsx_runtime17.jsx)(
            Cell,
            {
              fill: getThemeColor(entry.color, theme),
              stroke: "var(--chart-stroke-color, var(--mantine-color-body))",
              strokeWidth
            },
            index
          ))
        ]
      }
    ),
    withTooltip && (0, import_jsx_runtime17.jsx)(
      Tooltip,
      {
        animationDuration: tooltipAnimationDuration,
        isAnimationActive: false,
        content: ({ payload }) => {
          var _a;
          return (0, import_jsx_runtime17.jsx)(
            ChartTooltip,
            {
              payload: data,
              classNames: resolvedClassNames,
              styles: resolvedStyles,
              type: "radial",
              segmentId: tooltipDataSource === "segment" ? (_a = payload == null ? void 0 : payload[0]) == null ? void 0 : _a.name : void 0,
              valueFormatter
            }
          );
        },
        ...tooltipProps
      }
    ),
    children
  ] }) }) });
});
FunnelChart2.displayName = "@mantine/charts/FunnelChart";
FunnelChart2.classes = classes9;
export {
  AreaChart2 as AreaChart,
  AreaGradient,
  BarChart2 as BarChart,
  BubbleChart,
  ChartLegend,
  ChartTooltip,
  CompositeChart,
  DonutChart,
  FunnelChart2 as FunnelChart,
  LineChart2 as LineChart,
  PieChart2 as PieChart,
  RadarChart2 as RadarChart,
  RadialBarChart2 as RadialBarChart,
  ScatterChart2 as ScatterChart,
  Sparkline,
  getFilteredChartLegendPayload,
  getFilteredChartTooltipPayload,
  getSplitOffset
};
//# sourceMappingURL=@mantine_charts.js.map
