{
  "version": 3,
  "sources": ["../../.deno/chartjs-chart-sankey@0.14.0/node_modules/chartjs-chart-sankey/dist/chartjs-chart-sankey.esm.js"],
  "sourcesContent": ["/*!\n * chartjs-chart-sankey v0.14.0\n * https://github.com/kurkle/chartjs-chart-sankey#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT license\n */\nimport { DatasetController, Element } from 'chart.js';\nimport { toFont, valueOrDefault, getHoverColor, color } from 'chart.js/helpers';\n\nconst defined = (x)=>x !== undefined;\nfunction toTextLines(raw) {\n    if (!raw) return [];\n    const lines = [];\n    const inputs = Array.isArray(raw) ? raw : [\n        raw\n    ];\n    while(inputs.length){\n        const input = inputs.pop();\n        if (typeof input === 'string') {\n            lines.unshift(...input.split('\\n'));\n        } else if (Array.isArray(input)) {\n            inputs.push(...input);\n        } else if (input) {\n            lines.unshift(`${input}`);\n        }\n    }\n    return lines;\n}\nfunction validateSizeValue(size) {\n    if (!size || [\n        'min',\n        'max'\n    ].indexOf(size) === -1) {\n        return 'max';\n    }\n    return size;\n}\n\nconst flowSort = (a, b)=>{\n    if (b.flow === a.flow) return a.index - b.index;\n    return b.flow - a.flow;\n};\nconst setSizes = (nodes, size)=>{\n    const sizeMethod = validateSizeValue(size);\n    for (const node of nodes.values()){\n        node.from.sort(flowSort);\n        node.to.sort(flowSort);\n        node.size = Math[sizeMethod](node.in || node.out, node.out || node.in);\n    }\n};\nconst setPriorities = (nodes, priority)=>{\n    if (!priority) return;\n    for (const node of nodes.values()){\n        if (node.key in priority) {\n            node.priority = priority[node.key];\n        }\n    }\n};\nconst setColumns = (nodes, column)=>{\n    if (!column) return;\n    for (const node of nodes.values()){\n        if (node.key in column) {\n            node.column = true;\n            node.x = column[node.key];\n        }\n    }\n};\nconst getParsedData = (data, parsing)=>{\n    const { from: fromKey = 'from', to: toKey = 'to', flow: flowKey = 'flow' } = parsing;\n    return data.map(({ [fromKey]: from, [toKey]: to, [flowKey]: flow })=>({\n            from,\n            to,\n            flow\n        }));\n};\nfunction buildNodesFromData(data, { size, priority, column }) {\n    const nodes = new Map();\n    for(let i = 0; i < data.length; i++){\n        const { from, to, flow } = data[i];\n        const fromNode = nodes.get(from) ?? {\n            key: from,\n            in: 0,\n            out: 0,\n            size: 0,\n            from: [],\n            to: []\n        };\n        const toNode = (from === to ? fromNode : nodes.get(to)) ?? {\n            key: to,\n            in: 0,\n            out: 0,\n            size: 0,\n            from: [],\n            to: []\n        };\n        fromNode.out += flow;\n        fromNode.to.push({\n            key: to,\n            flow: flow,\n            index: i,\n            node: toNode,\n            addY: 0\n        });\n        if (fromNode.to.length === 1) {\n            nodes.set(from, fromNode);\n        }\n        toNode.in += flow;\n        toNode.from.push({\n            key: from,\n            flow: flow,\n            index: i,\n            node: fromNode,\n            addY: 0\n        });\n        if (toNode.from.length === 1) {\n            nodes.set(to, toNode);\n        }\n    }\n    setSizes(nodes, size);\n    setPriorities(nodes, priority);\n    setColumns(nodes, column);\n    return nodes;\n}\n\nconst SMALL_VALUE = 1e-6;\n const getAllKeysForward = (nodes, visited = new Set())=>{\n    const keys = [];\n    for (const node of nodes){\n        if (visited.has(node.key)) continue;\n        visited.add(node.key);\n        keys.push(node.key, ...getAllKeysForward(node.to.map((to)=>to.node), visited));\n    }\n    return keys;\n};\n const startColumn = (data, nodes)=>{\n    const startNodes = nodes.filter((node)=>node.from.length === 0);\n    const column = startNodes.map((node)=>node.key);\n    const startRef = getAllKeysForward(startNodes);\n    const referencedNodes = new Set(startRef);\n    for (const point of data){\n        if (!referencedNodes.has(point.from) && !referencedNodes.has(point.to)) {\n            column.push(point.from);\n            referencedNodes.add(point.from);\n        }\n        referencedNodes.add(point.to);\n    }\n    return column;\n};\n const nextColumn = (dataWithoutDirectLoops, remainingKeys)=>{\n    const remainingTo = new Set(dataWithoutDirectLoops.filter((flow)=>remainingKeys.has(flow.from)).map((flow)=>flow.to));\n    const remainingKeyArray = [\n        ...remainingKeys\n    ];\n    const columnsNotInTo = remainingKeyArray.filter((key)=>!remainingTo.has(key));\n    return columnsNotInTo.length ? columnsNotInTo : remainingKeyArray.slice(0, 1);\n};\nfunction calculateX(nodeMap, data, mode) {\n    const dataWithoutDirectLoops = data.filter((dp)=>dp.from !== dp.to);\n    const allKeys = [\n        ...nodeMap.keys()\n    ];\n    const allNodes = [\n        ...nodeMap.values()\n    ];\n    const keysToPlace = new Set(allKeys);\n    let x = 0;\n    while(keysToPlace.size){\n        const column = x === 0 ? startColumn(data, allNodes) : nextColumn(dataWithoutDirectLoops, keysToPlace);\n        if (!column.length) {\n            throw new Error('Fatal error: Unable to place nodes to columns. Please report this issue.');\n        }\n        for (const key of column){\n            const node = nodeMap.get(key);\n            if (node && !defined(node.x)) {\n                node.x = x;\n            }\n            keysToPlace.delete(key);\n        }\n        if (keysToPlace.size) {\n            x++;\n        }\n    }\n    const maxX = allNodes.reduce((max, node)=>Math.max(max, node.x), 0);\n    if (mode === 'edge') {\n        const from = new Set(data.map((dataPoint)=>dataPoint.from));\n        allKeys.filter((key)=>!from.has(key)).forEach((key)=>{\n            const node = nodeMap.get(key);\n            if (node && !node.column) {\n                node.x = maxX;\n            }\n        });\n    }\n    return maxX;\n}\nlet prevCountId = -1;\nfunction getCountId() {\n    prevCountId = prevCountId < 100 ? prevCountId + 1 : 0;\n    return prevCountId;\n}\nfunction nodeCount(list, prop, countId = getCountId()) {\n    let count = 0;\n    for (const elem of list){\n        if (elem.node._visited === countId) {\n            continue;\n        }\n        elem.node._visited = countId;\n        count += elem.node[prop].length + nodeCount(elem.node[prop], prop, countId);\n    }\n    return count;\n}\nconst flowByNodeCount = (prop)=>(a, b)=>nodeCount(a.node[prop], prop) - nodeCount(b.node[prop], prop) || a.node[prop].length - b.node[prop].length;\nfunction processFrom(node, y) {\n    if (!node.from.length) return y;\n    node.from.sort(flowByNodeCount('from'));\n    for (const flow of node.from){\n        const n = flow.node;\n        if (!defined(n.y)) {\n            n.y = y;\n            processFrom(n, y ? y + SMALL_VALUE : 0);\n        }\n        y = Math.max(n.y + n.out, y);\n    }\n    return node.y + node.size;\n}\nfunction processTo(node, y) {\n    if (!node.to.length) return y;\n    node.to.sort(flowByNodeCount('to'));\n    for (const flow of node.to){\n        const n = flow.node;\n        if (!defined(n.y)) {\n            n.y = y;\n            processTo(n, y ? y + SMALL_VALUE : 0);\n        }\n        y = Math.max(n.y + Math.max(n.in, n.out), y);\n    }\n    return node.y + node.size;\n}\nfunction setOrGetY(node, value) {\n    if (defined(node.y)) {\n        return node.y;\n    }\n    node.y = value;\n    return value;\n}\nfunction processRest(nodeArray, maxX) {\n    const leftNodes = nodeArray.filter((node)=>node.x === 0);\n    const rightNodes = nodeArray.filter((node)=>node.x === maxX);\n    const leftToDo = leftNodes.filter((node)=>!defined(node.y));\n    const rightToDo = rightNodes.filter((node)=>!defined(node.y));\n    const centerToDo = nodeArray.filter((node)=>node.x > 0 && node.x < maxX && !defined(node.y));\n    let leftY = leftNodes.reduce((acc, cur)=>Math.max(acc, cur.y + cur.out || 0), 0) + SMALL_VALUE;\n    let rightY = rightNodes.reduce((acc, cur)=>Math.max(acc, cur.y + cur.in || 0), 0) + SMALL_VALUE;\n    let centerY = 0;\n    if (leftY >= rightY) {\n        leftToDo.forEach((node)=>{\n            leftY = setOrGetY(node, leftY);\n            leftY = Math.max(leftY + node.out, processTo(node, leftY));\n        });\n        rightToDo.forEach((node)=>{\n            rightY = setOrGetY(node, rightY);\n            rightY = Math.max(rightY + node.in, processFrom(node, rightY));\n        });\n    } else {\n        leftToDo.forEach((node)=>{\n            leftY = setOrGetY(node, leftY);\n        });\n        rightToDo.forEach((node)=>{\n            rightY = setOrGetY(node, rightY);\n            rightY = Math.max(rightY + node.in, processFrom(node, rightY));\n        });\n    }\n    centerToDo.forEach((node)=>{\n        let y = nodeArray.filter((n)=>n.x === node.x && defined(n.y)).reduce((acc, cur)=>Math.max(acc, cur.y + Math.max(cur.in, cur.out)), 0);\n        y = setOrGetY(node, y);\n        y = Math.max(y + node.in, processFrom(node, y));\n        y = Math.max(y + node.out, processTo(node, y));\n        centerY = Math.max(centerY, y);\n    });\n    return Math.max(leftY, rightY, centerY);\n}\nconst fixTop = (nodeArray, maxX)=>{\n    let maxY = 0;\n    for(let x = 0; x <= maxX; x++){\n        const nodes = nodeArray.filter((n)=>n.x === x).sort((a, b)=>a.y - b.y);\n        let minY = 0;\n        for (const node of nodes){\n            if (node.y < minY) node.y = minY;\n            minY = node.y + node.size;\n        }\n        maxY = Math.max(maxY, minY);\n    }\n    return maxY;\n};\nconst findStartNode = (nodeArray, maxX)=>{\n    const size = [\n        ...nodeArray\n    ].sort((a, b)=>a.size - b.size).pop().size;\n    const biggest = nodeArray.filter((n)=>n.size === size);\n    if (biggest.length === 1) return biggest[0];\n    biggest.sort((a, b)=>a.x - b.x);\n    if (biggest[0].x === 0) return biggest[0];\n    if (biggest[biggest.length - 1].x === maxX) return biggest.pop();\n    const mid = Math.floor(biggest.length / 2);\n    return biggest[mid];\n};\nfunction calculateY(nodeArray, maxX) {\n    if (!nodeArray.length) return 0;\n    const start = findStartNode(nodeArray, maxX);\n    start.y = 0;\n    processFrom(start, 0);\n    processTo(start, 0);\n    processRest(nodeArray, maxX);\n    return fixTop(nodeArray, maxX);\n}\nfunction calculateYUsingPriority(nodeArray, maxX) {\n    let maxY = 0;\n    let nextYStart = 0;\n    for(let x = 0; x <= maxX; x++){\n        let y = nextYStart;\n        const nodes = nodeArray.filter((node)=>node.x === x).sort((a, b)=>(a.priority ?? 0) - (b.priority ?? 0));\n        nextYStart = nodes.length ? nodes[0].to.filter((to)=>to.node.x > x + 1).reduce((acc, cur)=>acc + cur.flow, 0) || 0 : 0;\n        for (const node of nodes){\n            node.y = y;\n            y += Math.max(node.out, node.in);\n        }\n        maxY = Math.max(y, maxY);\n    }\n    return maxY;\n}\nconst nodeByXYSize = (a, b)=>{\n    if (a.x !== b.x) return a.x - b.x;\n    if (a.y === b.y) return a.size - b.size;\n    return a.y - b.y;\n};\n function addPadding(nodeArray, padding) {\n    let maxY = 0;\n    const columnXs = new Map();\n    const grid = [];\n    const getColIndex = (x)=>{\n        if (!columnXs.has(x)) {\n            columnXs.set(x, grid.length);\n            grid.push([]);\n        }\n        return columnXs.get(x);\n    };\n    nodeArray.sort(nodeByXYSize);\n    for (const node of nodeArray){\n        const colIdx = getColIndex(node.x);\n        const column = grid[colIdx];\n        if (node.y) {\n            column.push(node.y);\n            let paddings = column.length;\n            if (node.in) {\n                for(let col = 0; col < colIdx; col++){\n                    const otherColumn = grid[col];\n                    for(let row = 0; row < otherColumn.length; row++){\n                        if (otherColumn[row] > node.y) break;\n                        paddings = Math.max(row + 1, paddings);\n                    }\n                }\n                while(column.length < paddings)column.push(node.y);\n            }\n            node.y += paddings * padding;\n        }\n        maxY = Math.max(maxY, node.y + Math.max(node.in, node.out));\n    }\n    return maxY;\n}\nfunction sortFlows(nodeArray) {\n    nodeArray.forEach((node)=>{\n        const nodeSize = node.size;\n        const overlapFrom = nodeSize < node.in;\n        const overlapTo = nodeSize < node.out;\n        let addY = 0;\n        let len = node.from.length;\n        node.from.sort((a, b)=>a.node.y + a.node.out / 2 - (b.node.y + b.node.out / 2)).forEach((flow, idx)=>{\n            if (overlapFrom) {\n                flow.addY = idx * (nodeSize - flow.flow) / (len - 1);\n            } else {\n                flow.addY = addY;\n                addY += flow.flow;\n            }\n        });\n        addY = 0;\n        len = node.to.length;\n        node.to.sort((a, b)=>a.node.y + a.node.in / 2 - (b.node.y + b.node.in / 2)).forEach((flow, idx)=>{\n            if (overlapTo) {\n                flow.addY = idx * (nodeSize - flow.flow) / (len - 1);\n            } else {\n                flow.addY = addY;\n                addY += flow.flow;\n            }\n        });\n    });\n}\nfunction layout(nodes, data, { priority, height, nodePadding, modeX }) {\n    const nodeArray = [\n        ...nodes.values()\n    ];\n    const maxX = calculateX(nodes, data, modeX);\n    const maxY = priority ? calculateYUsingPriority(nodeArray, maxX) : calculateY(nodeArray, maxX);\n    const padding = maxY / height * nodePadding;\n    const maxYWithPadding = addPadding(nodeArray, padding);\n    sortFlows(nodeArray);\n    return {\n        maxX,\n        maxY: maxYWithPadding\n    };\n}\n\nfunction getAddY(arr, key, index) {\n    for (const item of arr){\n        if (item.key === key && item.index === index) {\n            return item.addY;\n        }\n    }\n    return 0;\n}\nclass SankeyController extends DatasetController {\n    parseObjectData(meta, data, start, count) {\n        const sankeyData = getParsedData(data, this.options.parsing);\n        const { xScale, yScale } = meta;\n        const parsed = [];\n        const nodes = this._nodes = buildNodesFromData(sankeyData, this.options);\n        const { maxX, maxY } = layout(nodes, sankeyData, {\n            priority: !!this.options.priority,\n            height: this.chart.canvas.height,\n            nodePadding: this.options.nodePadding,\n            modeX: this.options.modeX\n        });\n        this._maxX = maxX;\n        this._maxY = maxY;\n        if (!xScale || !yScale) return [];\n        for(let i = 0, ilen = sankeyData.length; i < ilen; ++i){\n            const dataPoint = sankeyData[i];\n            const from = nodes.get(dataPoint.from);\n            const to = nodes.get(dataPoint.to);\n            if (!from || !to) continue;\n            const fromY = (from.y ?? 0) + getAddY(from.to, dataPoint.to, i);\n            const toY = (to.y ?? 0) + getAddY(to.from, dataPoint.from, i);\n            parsed.push({\n                x: xScale.parse(from.x, i),\n                y: yScale.parse(fromY, i),\n                _custom: {\n                    from,\n                    to,\n                    x: xScale.parse(to.x, i),\n                    y: yScale.parse(toY, i),\n                    height: yScale.parse(dataPoint.flow, i),\n                    flow: dataPoint.flow\n                }\n            });\n        }\n        return parsed.slice(start, start + count);\n    }\n    getMinMax(scale) {\n        return {\n            min: 0,\n            max: scale === this._cachedMeta.xScale ? this._maxX : this._maxY\n        };\n    }\n    update(mode) {\n        const { data } = this._cachedMeta;\n        this.updateElements(data, 0, data.length, mode);\n    }\n    updateElements(elems, start, count, mode) {\n        const { xScale, yScale } = this._cachedMeta;\n        if (!xScale || !yScale) return;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const { borderWidth, nodeWidth = 10 } = this.options;\n        const borderSpace = borderWidth ? borderWidth / 2 + 0.5 : 0;\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const custom = parsed._custom;\n            const y = yScale.getPixelForValue(parsed.y);\n            this.updateElement(elems[i], i, {\n                x: xScale.getPixelForValue(parsed.x) + nodeWidth + borderSpace,\n                y,\n                x2: xScale.getPixelForValue(custom.x) - borderSpace,\n                y2: yScale.getPixelForValue(custom.y),\n                from: custom.from,\n                to: custom.to,\n                progress: mode === 'reset' ? 0 : 1,\n                height: Math.abs(yScale.getPixelForValue(parsed.y + custom.height) - y),\n                options: this.resolveDataElementOptions(i, mode)\n            }, mode);\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n    _drawLabels() {\n        const ctx = this.chart.ctx;\n        const options = this.options;\n        const nodes = this._nodes || new Map();\n        const size = validateSizeValue(options.size);\n        const borderWidth = options.borderWidth ?? 1;\n        const nodeWidth = options.nodeWidth ?? 10;\n        const labels = options.labels;\n        const { xScale, yScale } = this._cachedMeta;\n        if (!xScale || !yScale) return;\n        ctx.save();\n        const chartArea = this.chart.chartArea;\n        for (const node of nodes.values()){\n            const x = xScale.getPixelForValue(node.x);\n            const y = yScale.getPixelForValue(node.y);\n            const max = Math[size](node.in || node.out, node.out || node.in);\n            const height = Math.abs(yScale.getPixelForValue(node.y + max) - y);\n            const label = labels?.[node.key] ?? node.key;\n            let textX = x;\n            ctx.fillStyle = options.color ?? 'black';\n            ctx.textBaseline = 'middle';\n            if (x < chartArea.width / 2) {\n                ctx.textAlign = 'left';\n                textX += nodeWidth + borderWidth + 4;\n            } else {\n                ctx.textAlign = 'right';\n                textX -= borderWidth + 4;\n            }\n            this._drawLabel(label, y, height, ctx, textX);\n        }\n        ctx.restore();\n    }\n    _drawLabel(label, y, height, ctx, textX) {\n        const font = toFont(this.options.font, this.chart.options.font);\n        const lines = toTextLines(label);\n        const lineCount = lines.length;\n        const middle = y + height / 2;\n        const textHeight = font.lineHeight;\n        const padding = valueOrDefault(this.options.padding, textHeight / 2);\n        ctx.font = font.string;\n        if (lineCount > 1) {\n            const top = middle - textHeight * lineCount / 2 + padding;\n            for(let i = 0; i < lineCount; i++){\n                ctx.fillText(lines[i], textX, top + i * textHeight);\n            }\n        } else {\n            ctx.fillText(label, textX, middle);\n        }\n    }\n    _drawNodes() {\n        const ctx = this.chart.ctx;\n        const nodes = this._nodes || new Map();\n        const { borderColor, borderWidth = 0, nodeWidth = 10, size } = this.options;\n        const sizeMethod = validateSizeValue(size);\n        const { xScale, yScale } = this._cachedMeta;\n        ctx.save();\n        if (borderColor && borderWidth) {\n            ctx.strokeStyle = borderColor;\n            ctx.lineWidth = borderWidth;\n        }\n        for (const node of nodes.values()){\n            ctx.fillStyle = node.color ?? 'black';\n            const x = xScale.getPixelForValue(node.x);\n            const y = yScale.getPixelForValue(node.y);\n            const max = Math[sizeMethod](node.in || node.out, node.out || node.in);\n            const height = Math.abs(yScale.getPixelForValue(node.y + max) - y);\n            if (borderWidth) {\n                ctx.strokeRect(x, y, nodeWidth, height);\n            }\n            ctx.fillRect(x, y, nodeWidth, height);\n        }\n        ctx.restore();\n    }\n draw() {\n        const ctx = this.chart.ctx;\n        const data = this.getMeta().data ?? [];\n        const active = [];\n        for(let i = 0, ilen = data.length; i < ilen; ++i){\n            const flow = data[i];\n             flow.from.color = flow.options.colorFrom;\n            flow.to.color = flow.options.colorTo;\n            if (flow.active) {\n                active.push(flow);\n            }\n        }\n        for (const flow of active){\n            flow.from.color = flow.options.colorFrom;\n            flow.to.color = flow.options.colorTo;\n        }\n        this._drawNodes();\n        for(let i = 0, ilen = data.length; i < ilen; ++i){\n            data[i].draw(ctx);\n        }\n        this._drawLabels();\n    }\n}\nSankeyController.id = 'sankey';\nSankeyController.defaults = {\n    dataElementType: 'flow',\n    animations: {\n        numbers: {\n            type: 'number',\n            properties: [\n                'x',\n                'y',\n                'x2',\n                'y2',\n                'height'\n            ]\n        },\n        progress: {\n            easing: 'linear',\n            duration: (ctx)=>ctx.type === 'data' ? (ctx.parsed._custom.x - ctx.parsed.x) * 200 : undefined,\n            delay: (ctx)=>ctx.type === 'data' ? ctx.parsed.x * 500 + ctx.dataIndex * 20 : undefined\n        },\n        colors: {\n            type: 'color',\n            properties: [\n                'colorFrom',\n                'colorTo'\n            ]\n        }\n    },\n    color: 'black',\n    borderColor: 'black',\n    borderWidth: 1,\n    modeX: 'edge',\n    nodeWidth: 10,\n    nodePadding: 10,\n    transitions: {\n        hide: {\n            animations: {\n                colors: {\n                    type: 'color',\n                    properties: [\n                        'colorFrom',\n                        'colorTo'\n                    ],\n                    to: 'transparent'\n                }\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    type: 'color',\n                    properties: [\n                        'colorFrom',\n                        'colorTo'\n                    ],\n                    from: 'transparent'\n                }\n            }\n        }\n    }\n};\nSankeyController.overrides = {\n    interaction: {\n        mode: 'nearest',\n        intersect: true\n    },\n    datasets: {\n        clip: false,\n        parsing: {\n            from: 'from',\n            to: 'to',\n            flow: 'flow'\n        }\n    },\n    plugins: {\n        tooltip: {\n            callbacks: {\n                title () {\n                    return '';\n                },\n                label (context) {\n                    const parsedCustom = context.parsed._custom;\n                    return parsedCustom.from.key + ' -> ' + parsedCustom.to.key + ': ' + parsedCustom.flow;\n                }\n            }\n        },\n        legend: {\n            display: false\n        }\n    },\n    scales: {\n        x: {\n            type: 'linear',\n            bounds: 'data',\n            display: false,\n            min: 0,\n            offset: false\n        },\n        y: {\n            type: 'linear',\n            bounds: 'data',\n            display: false,\n            min: 0,\n            reverse: true,\n            offset: false\n        }\n    },\n    layout: {\n        padding: {\n            top: 3,\n            left: 3,\n            right: 13,\n            bottom: 3\n        }\n    }\n};\n\nconst controlPoints = (x, y, x2, y2)=>x < x2 ? {\n        cp1: {\n            x: x + (x2 - x) / 3 * 2,\n            y\n        },\n        cp2: {\n            x: x + (x2 - x) / 3,\n            y: y2\n        }\n    } : {\n        cp1: {\n            x: x - (x - x2) / 3,\n            y: 0\n        },\n        cp2: {\n            x: x2 + (x - x2) / 3,\n            y: 0\n        }\n    };\nconst pointInLine = (p1, p2, t)=>({\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    });\nconst applyAlpha = (original, alpha)=>color(original).alpha(alpha).rgbString();\nconst getColorOption = (option, alpha)=>typeof option === 'string' ? applyAlpha(option, alpha) : option;\nfunction setStyle(ctx, { x, x2, options }) {\n    let fill = 'black';\n    if (options.colorMode === 'from') {\n        fill = getColorOption(options.colorFrom, options.alpha);\n    } else if (options.colorMode === 'to') {\n        fill = getColorOption(options.colorTo, options.alpha);\n    } else if (typeof options.colorFrom === 'string' && typeof options.colorTo === 'string') {\n        fill = ctx.createLinearGradient(x, 0, x2, 0);\n        fill.addColorStop(0, applyAlpha(options.colorFrom, options.alpha));\n        fill.addColorStop(1, applyAlpha(options.colorTo, options.alpha));\n    }\n    ctx.fillStyle = fill;\n    ctx.strokeStyle = fill;\n    ctx.lineWidth = 0.5;\n}\nclass Flow extends Element {\n draw(ctx) {\n        const { x, x2, y, y2, height, progress } = this;\n        const { cp1, cp2 } = controlPoints(x, y, x2, y2);\n        if (progress === 0) {\n            return;\n        }\n        ctx.save();\n        if (progress < 1) {\n            ctx.beginPath();\n            ctx.rect(x, Math.min(y, y2), (x2 - x) * progress + 1, Math.abs(y2 - y) + height + 1);\n            ctx.clip();\n        }\n        setStyle(ctx, this);\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, x2, y2);\n        ctx.lineTo(x2, y2 + height);\n        ctx.bezierCurveTo(cp2.x, cp2.y + height, cp1.x, cp1.y + height, x, y + height);\n        ctx.lineTo(x, y);\n        ctx.stroke();\n        ctx.closePath();\n        ctx.fill();\n        ctx.restore();\n    }\n inRange(mouseX, mouseY, useFinalPosition) {\n        const { x, y, x2, y2, height } = this.getProps([\n            'x',\n            'y',\n            'x2',\n            'y2',\n            'height'\n        ], useFinalPosition);\n        if (mouseX < x || mouseX > x2) {\n            return false;\n        }\n        const { cp1, cp2 } = controlPoints(x, y, x2, y2);\n        const t = (mouseX - x) / (x2 - x);\n        const p1 = {\n            x,\n            y\n        };\n        const p2 = {\n            x: x2,\n            y: y2\n        };\n        const a = pointInLine(p1, cp1, t);\n        const b = pointInLine(cp1, cp2, t);\n        const c = pointInLine(cp2, p2, t);\n        const d = pointInLine(a, b, t);\n        const e = pointInLine(b, c, t);\n        const topY = pointInLine(d, e, t).y;\n        return mouseY >= topY && mouseY <= topY + height;\n    }\n inXRange(mouseX, useFinalPosition) {\n        const { x, x2 } = this.getProps([\n            'x',\n            'x2'\n        ], useFinalPosition);\n        return mouseX >= x && mouseX <= x2;\n    }\n inYRange(mouseY, useFinalPosition) {\n        const { y, y2, height } = this.getProps([\n            'y',\n            'y2',\n            'height'\n        ], useFinalPosition);\n        const minY = Math.min(y, y2);\n        const maxY = Math.max(y, y2) + height;\n        return mouseY >= minY && mouseY <= maxY;\n    }\n getCenterPoint(useFinalPosition) {\n        const { x, y, x2, y2, height } = this.getProps([\n            'x',\n            'y',\n            'x2',\n            'y2',\n            'height'\n        ], useFinalPosition);\n        return {\n            x: (x + x2) / 2,\n            y: (y + y2 + height) / 2\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n getRange(axis) {\n        return axis === 'x' ? this.width / 2 : this.height / 2;\n    }\n    constructor(cfg){\n        super();\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n}\nFlow.id = 'flow';\nFlow.defaults = {\n    colorFrom: 'red',\n    colorTo: 'green',\n    colorMode: 'gradient',\n    alpha: 0.5,\n    hoverColorFrom: (_ctx, options)=>getHoverColor(options.colorFrom),\n    hoverColorTo: (_ctx, options)=>getHoverColor(options.colorTo)\n};\nFlow.descriptors = {\n    _scriptable: true\n};\n\nexport { Flow, SankeyController };\n"],
  "mappings": "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",
  "names": ["defined"]
}
